<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta name="theme-color" content="#0a0c10">
  <meta name="color-scheme" content="dark">
  <title>ClawCondos</title>
  
  <!-- Preload fonts for performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <link rel="stylesheet" href="/styles/main.css?v=9">
  <link rel="stylesheet" href="/styles/media-upload.css">
  <link rel="stylesheet" href="/styles/voice-recorder.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
</head>
<body>
  <!-- Toast container for notifications -->
  <div class="toast-container" id="toastContainer"></div>
  
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       LOGIN MODAL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="modal-overlay hidden" id="loginModal">
    <div class="modal">
      <h2 class="modal-title">ğŸ™ï¸ ClawCondos</h2>
      <p class="modal-desc">Enter your OpenClaw gateway token to connect.</p>
      <div class="form-group">
        <label class="form-label">Token</label>
        <input type="password" class="form-input" id="loginPassword" placeholder="Gateway token" 
               onkeypress="if(event.key==='Enter')doLogin()">
      </div>
      <button class="form-btn" onclick="doLogin()">Connect</button>
      <div class="form-error" id="loginError"></div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CREATE GOAL MODAL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="modal-overlay hidden" id="createGoalModal">
    <div class="modal">
      <h2 class="modal-title">New Goal</h2>
      <p class="modal-desc">Create a new condo (goal). You can attach sessions and spawn agents inside it.</p>
      <div class="form-group">
        <label class="form-label">Title</label>
        <input type="text" class="form-input" id="createGoalTitle" placeholder="e.g., Rebrand Dashboard" 
               onkeypress="if(event.key==='Enter')createGoal()">
      </div>
      <div class="form-group">
        <label class="form-label">Deadline (optional)</label>
        <input type="text" class="form-input" id="createGoalDeadline" placeholder="YYYY-MM-DD or freeform">
      </div>
      <div style="display:flex; gap:10px; margin-top: 10px;">
        <button class="form-btn" onclick="createGoal()">Create</button>
        <button class="form-btn" style="background: var(--bg-input); border: 1px solid var(--border);" onclick="hideCreateGoalModal()">Cancel</button>
      </div>
      <div class="form-error" id="createGoalError"></div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ATTACH/MOVE SESSION MODAL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="modal-overlay hidden" id="attachSessionModal">
    <div class="modal" style="max-width: 520px;">
      <h2 class="modal-title">Attach session to goal</h2>
      <p class="modal-desc">Pick a condo. This moves the session (removes it from any other condo).</p>
      <div class="form-group">
        <label class="form-label">Session</label>
        <div class="session-pill" id="attachSessionPill">â€”</div>
      </div>
      <div class="form-group">
        <label class="form-label">Goal</label>
        <div class="goal-picker" id="goalPicker"></div>
      </div>
      <div style="display:flex; gap:10px; margin-top: 10px;">
        <button class="form-btn" onclick="confirmAttachSession()">Attach</button>
        <button class="form-btn" style="background: var(--bg-input); border: 1px solid var(--border);" onclick="hideAttachSessionModal()">Cancel</button>
      </div>
      <div class="form-error" id="attachSessionError"></div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SUGGEST GOAL MODAL (per-session AI categorization)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="modal-overlay hidden" id="suggestGoalModal">
    <div class="modal" style="max-width: 560px;">
      <h2 class="modal-title">ğŸ·ï¸ Suggest Goal</h2>
      <p class="modal-desc" id="suggestGoalDesc">Analyzing session...</p>
      <div class="form-group">
        <label class="form-label">Session</label>
        <div class="session-pill" id="suggestSessionPill">â€”</div>
      </div>
      <div class="form-group" id="suggestGoalLoading" style="text-align: center; padding: 20px;">
        <div class="loading-spinner"></div>
        <p style="color: var(--text-dim); margin-top: 10px;">Analyzing conversation...</p>
      </div>
      <div class="form-group" id="suggestGoalResults" style="display: none;">
        <label class="form-label">Suggested Goals</label>
        <div class="goal-suggestions" id="goalSuggestions"></div>
      </div>
      <div class="form-group" id="suggestNewGoalSection" style="display: none;">
        <label class="form-label">Or create a new goal</label>
        <input type="text" class="form-input" id="suggestNewGoalTitle" placeholder="New goal title...">
        <button class="form-btn" style="margin-top: 8px;" onclick="createGoalFromSuggestion()">Create & Assign</button>
      </div>
      <div style="display:flex; gap:10px; margin-top: 16px;">
        <button class="form-btn" style="background: var(--bg-input); border: 1px solid var(--border);" onclick="hideSuggestGoalModal()">Cancel</button>
        <button class="form-btn" id="skipCategorizationBtn" onclick="hideSuggestGoalModal()">Skip</button>
      </div>
      <div class="form-error" id="suggestGoalError"></div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SPAWN TASK SESSION MODAL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="modal-overlay hidden" id="spawnTaskModal">
    <div class="modal" style="max-width: 440px;">
      <h2 class="modal-title">Spawn Session for Task</h2>
      <p class="modal-desc" id="spawnTaskDesc">Pick an agent and model to work on this task.</p>
      <div class="form-group">
        <label class="form-label">Agent</label>
        <select class="form-input" id="spawnAgentSelect"></select>
      </div>
      <div class="form-group">
        <label class="form-label">Model</label>
        <select class="form-input" id="spawnModelSelect">
          <option value="claude-sonnet-4-5-20250929">sonnet-4-5</option>
          <option value="claude-opus-4-5-20251101">opus-4-5</option>
          <option value="claude-haiku-4-5-20251001">haiku-4-5</option>
        </select>
      </div>
      <div style="display:flex; gap:10px; margin-top: 10px;">
        <button class="form-btn" id="spawnTaskBtn" onclick="confirmSpawnTask()">Spawn Session</button>
        <button class="form-btn" style="background: var(--bg-input); border: 1px solid var(--border);" onclick="hideSpawnTaskModal()">Cancel</button>
      </div>
      <div class="form-error" id="spawnTaskError"></div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ORGANIZE WIZARD (Sequential session triage)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="modal-overlay hidden" id="organizeWizardModal">
    <div class="modal organize-wizard">
      <!-- Header -->
      <div class="wiz-header">
        <div class="wiz-header-left">
          <h2 class="wiz-title">Organize Sessions</h2>
          <div class="wiz-progress-text"><span id="wizardProgress">1 of 41</span> Â· <span id="wizardStats">0 organized</span></div>
        </div>
        <button class="wiz-close" onclick="closeOrganizeWizard()">âœ•</button>
      </div>
      
      <!-- Progress bar -->
      <div class="wiz-progress-bar"><div class="wiz-progress-fill" id="wizardProgressBar"></div></div>
      
      <!-- Two Column Layout -->
      <div class="wiz-columns" id="wizardContent">
        <!-- LEFT: Session Info -->
        <div class="wiz-left">
          <div class="wiz-section-label">SESSION</div>
          <div class="wiz-session-card">
            <div class="wiz-session-icon" id="wizardSessionIcon">ğŸ’¬</div>
            <div class="wiz-session-name" id="wizardSessionTitle">Session Title</div>
          </div>
          <div class="wiz-session-key" id="wizardSessionKey">agent:main:...</div>
          
          <div class="wiz-section-label" style="margin-top: 20px;">CONTENT PREVIEW</div>
          <div class="wiz-content-box" id="wizardSummary">
            Loading session data...
          </div>
        </div>
        
        <!-- RIGHT: Goal Assignment -->
        <div class="wiz-right">
          <div class="wiz-section-label">SUGGESTED GOAL</div>
          <div class="wiz-goal-card" id="wizardProposal">
            <div class="wiz-goal-icon">ğŸ¯</div>
            <div class="wiz-goal-info" id="wizardProposedGoal">
              <div class="wiz-goal-name">Analyzing...</div>
              <div class="wiz-goal-reason"></div>
            </div>
          </div>
          
          <!-- Actions -->
          <div class="wiz-actions">
            <button class="wiz-btn-accept" id="wizardAcceptBtn" onclick="acceptWizardProposal()">
              âœ“ Accept
            </button>
            <button class="wiz-btn-skip" onclick="skipWizardSession()">
              Skip â†’
            </button>
          </div>
          
          <button class="wiz-btn-change" onclick="showWizardGoalPicker()">
            Choose different goal...
          </button>
          
          <!-- Goal Picker (hidden) -->
          <div class="wiz-picker hidden" id="wizardGoalPicker">
            <div class="wiz-picker-list" id="wizardGoalList"></div>
            <div class="wiz-picker-new">
              <input type="text" class="wiz-picker-input" id="wizardNewGoalTitle" placeholder="Or create new...">
              <button class="wiz-picker-create" onclick="createGoalInWizard()">+</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SEARCH PALETTE (Cmd+K)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="modal-overlay hidden" id="searchPalette" onclick="closeSearchPalette()">
    <div class="search-palette" onclick="event.stopPropagation()">
      <div class="search-palette-input-wrap">
        <span class="search-palette-icon">&#x1F50D;</span>
        <input type="text" class="search-palette-input" id="searchPaletteInput"
               placeholder="Search goals and sessions..."
               oninput="onSearchPaletteInput()"
               onkeydown="handleSearchPaletteKey(event)">
        <kbd class="search-palette-hint">ESC</kbd>
      </div>
      <div class="search-palette-results" id="searchPaletteResults"></div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MOBILE HEADER
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <header class="mobile-header" id="mobileHeader">
    <button class="menu-btn" id="menuBtn" onclick="toggleSidebar()">â˜°</button>
    <button class="back-btn" id="backBtn" onclick="goBack()" style="display: none;">â†</button>
    <span class="mobile-title" id="mobileTitle">ClawCondos</span>
    <div class="mobile-actions">
      <button class="menu-btn" onclick="refresh()" title="Refresh">â†»</button>
    </div>
  </header>
  
  <!-- Sidebar Overlay -->
  <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SIDEBAR
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-header" onclick="showOverview()">
      <img src="media/clawcondos-logo.png" alt="ClawCondos" class="logo-img">
      <span class="brand">ClawCondos</span>
    </div>

    <button class="sidebar-search-btn" onclick="event.stopPropagation(); openSearchPalette()" title="Search (Cmd+K)">
      &#x1F50D; Search <kbd>K</kbd>
    </button>

    <div class="sidebar-content">
      <!-- Condos (Goals) -->
      <div class="section">
        <div class="section-header">
          <span class="section-title">Condos</span>
          <div class="goal-time-filter">
            <select id="goalTimeFilterSelect" onchange="setGoalTimeFilter(this.value)">
              <option value="1">24h</option>
              <option value="7" selected>7d</option>
              <option value="30">30d</option>
              <option value="all">All</option>
            </select>
          </div>
          <button class="section-action" id="markAllReadBtn" onclick="markAllSessionsRead()" title="Mark all read" style="display: none;">âœ“</button>
          <button class="section-action" onclick="showCreateGoalModal()" title="New goal">ï¼‹</button>
          <button class="section-action" onclick="refresh()" title="Refresh">â†»</button>
        </div>
        <div id="goalsList" style="padding: 4px 0;"></div>
        <div id="uncategorizedLink" class="uncategorized-link" style="display: none;" onclick="showOverview(); scrollToSection('recentActivitySection')"></div>
        <div id="sessionsList" style="display: none;"></div>
      </div>
      
      <!-- Apps -->
      <div class="section">
        <div class="section-header">
          <span class="section-title">Apps</span>
        </div>
        <div id="appsList"></div>
      </div>
      
      <!-- Agents -->
      <div class="section">
        <div class="section-header">
          <span class="section-title">Agents</span>
        </div>
        <div id="agentsList"></div>
      </div>
    </div>
    
    <div class="sidebar-footer">
      <a href="/control/" class="control-ui-btn" title="Open Clawdbot Control UI">
        ğŸ¤– Clawdbot UI
      </a>
      <div class="connection-status" onclick="showLoginModal()">
        <span class="connection-dot" id="connectionDot" style="background: var(--yellow);" title="Connecting to gateway..."></span>
        <span id="connectionText">Connecting...</span>
      </div>
    </div>
  </aside>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MAIN CONTENT
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <main class="main">
    <header class="main-header">
      <h1 class="main-title" id="mainTitle">Dashboard</h1>
      <div class="header-status idle" id="headerStatusIndicator" data-tooltip="Ready" style="display: none;"></div>
      <span class="main-subtitle" id="mainSubtitle"></span>
      <div class="main-header-spacer"></div>
      <button class="header-btn" id="headerAction" onclick="headerAction()" style="display: none;">Action</button>
      <button class="header-btn" onclick="refresh()">â†» Refresh</button>
    </header>
    
    <div class="main-content">
      <!-- Overview View -->
      <div class="view active" id="overviewView">
        <div class="overview-content">
          <!-- Stats Grid -->
          <div class="stats-grid" id="statsGrid">
            <div class="stat-card clickable accent-blue" onclick="scrollToSection('recentActivitySection')" title="View sessions">
              <div class="stat-label">Active Sessions</div>
              <div class="stat-value" id="statActiveSessions">-</div>
              <div class="stat-trend" id="statSessionsTrend"></div>
            </div>
            <div class="stat-card clickable accent-yellow" onclick="filterGoalsByStatus('active')" title="View pending goals">
              <div class="stat-label">Pending Goals</div>
              <div class="stat-value" id="statPendingGoals">-</div>
            </div>
            <div class="stat-card clickable accent-green" onclick="filterGoalsByStatus('done')" title="View completed goals">
              <div class="stat-label">Completed</div>
              <div class="stat-value" id="statCompletedGoals">-</div>
            </div>
            <div class="stat-card clickable accent-red" onclick="showErrorSessions()" title="View sessions with errors">
              <div class="stat-label">Errors</div>
              <div class="stat-value stat-error" id="statErrors">-</div>
            </div>
          </div>

          <!-- Recent Sessions -->
          <div class="grid-section" id="recentActivitySection">
            <div class="grid-header">
              <h2 class="grid-title">Recent Sessions</h2>
              <span class="grid-count" id="recentSessionCount">0</span>
            </div>
            <div class="cards-grid" id="recentSessionsGrid"></div>
          </div>
        </div>
      </div>
      
      <!-- Goal View -->
      <div class="view" id="goalView">
        <div class="goal-shell" id="goalShell">
          <section class="goal-chat" id="goalChatPanel">
            <div class="goal-chat-header">
              <div style="display:flex; gap:10px; align-items:baseline; min-width:0;">
                <div>Chat</div>
                <div class="goal-chat-meta" id="goalChatMeta" style="min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">â€”</div>
              </div>
              <div style="display:flex; gap:8px; align-items:center;">
                <div class="goal-history" id="goalHistoryWrap" style="display:none;">
                  <span class="goal-history-label">History</span>
                  <select class="goal-history-select" id="goalHistorySelect" onchange="handleGoalHistoryChange(this.value)"></select>
                </div>
                <div class="session-state-pill" id="goalSessionStatePill" title="Status">
                  <span class="session-state-dot blink-idle" id="goalSessionStateDot"></span>
                  <span class="session-state-label" id="goalSessionStateLabel">Idle</span>
                </div>
                <button class="ghost-btn" id="goalOpenBtn" onclick="openGoalChatInFull()">Open â†’</button>
              </div>
            </div>
            <div class="goal-chat-body">
              <div id="goalKickoffOverlay" style="display:none; padding:18px 14px; border-bottom:1px solid rgba(255,255,255,0.06);">
                <div style="font-weight:600; margin-bottom:6px;">This goal hasn't started yet</div>
                <div style="color: var(--text-dim); font-size:0.9rem; margin-bottom:12px;">Kick off to create the first session and begin execution.</div>
                <button class="ghost-btn" style="border-color: rgba(96,165,250,.55);" onclick="kickOffGoal()">Kick Off Goal</button>
              </div>
              <div class="chat-messages" id="goal_chatMessages"></div>
            </div>
            <div id="composerMountGoal"></div>
          </section>

          <section class="goal-right" id="goalRightPanel">
            <div class="goal-right-header">
              <div>
                <div class="goal-right-title" id="goalHeroTitle">Goal</div>
                <div class="goal-right-meta">
                  <span id="goalCondoName">Condo</span>
                  <span>Â·</span>
                  <span>Updated: <b id="goalLastUpdated">â€”</b></span>
                </div>
              </div>
              <div class="goal-right-actions">
                <button class="ghost-btn" id="goalMarkDoneBtn" onclick="toggleGoalDone()">Mark done</button>
                <button class="ghost-btn" onclick="showAttachSessionModal(null)">â›“</button>
                <button class="ghost-btn danger" onclick="promptDeleteGoal()" title="Delete goal">Delete</button>
              </div>
            </div>

            <div class="goal-def">
              <div class="goal-def-display" id="goalDefDisplay" onclick="startGoalDefEdit()">Click to add a definitionâ€¦ <small>(click to edit)</small></div>
              <div class="goal-def-edit" id="goalDefEdit">
                <textarea id="goalDefTA" rows="6"></textarea>
                <div class="goal-def-actions">
                  <button class="ghost-btn" onclick="saveGoalDefEdit()">Save</button>
                  <button class="ghost-btn" onclick="cancelGoalDefEdit()">Cancel</button>
                </div>
              </div>
            </div>

            <div class="goal-tabs">
              <div class="goal-tab active" id="goalTabTasks" onclick="setGoalTab('tasks')">Tasks</div>
              <div class="goal-tab" id="goalTabFiles" onclick="setGoalTab('files')">Files</div>
            </div>

            <div class="goal-pane" id="goalPane"></div>
          </section>
        </div>
      </div>

      <!-- Chat View -->
      <div class="view" id="chatView">
        <div class="session-info" id="sessionInfo">
          <span class="session-info-item">ğŸ“ <span id="sessionKeyDisplay">-</span></span>
          <span class="session-info-item" title="Session model (switching model will reset the session)">ğŸ¤–
            <select class="session-model-select" id="sessionModelSelect" onchange="handleSessionModelChange(this.value)"></select>
          </span>
          <span class="session-info-item">ğŸ“Š <span id="sessionTokens">-</span> tokens</span>
          <span class="session-info-spacer"></span>

          <div class="verbose-toggle" id="verboseToggle" title="Debug visibility: sends /verbose on|full|off to this session">
            <button class="verbose-btn" data-verbose="off" onclick="setVerboseMode('off')">V off</button>
            <button class="verbose-btn" data-verbose="on" onclick="setVerboseMode('on')">V on</button>
            <button class="verbose-btn" data-verbose="full" onclick="setVerboseMode('full')">V full</button>
          </div>

          <div class="export-group">
            <button class="export-btn" onclick="exportChatAsMarkdown()" title="Export as Markdown">
              <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
              Export
            </button><button class="export-btn export-btn-icon" onclick="copyChatAsMarkdown()" title="Copy as Markdown">
              <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
            </button>
          </div>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        
        <!-- Drop overlay for drag & drop -->
        <div class="drop-overlay" id="dropOverlay">
          <div class="drop-overlay-content">
            <div class="drop-overlay-icon">ğŸ“</div>
            <div class="drop-overlay-text">Drop files here</div>
            <div class="drop-overlay-hint">Images and audio supported</div>
          </div>
        </div>
        
        <div class="reconnect-overlay" id="reconnectOverlay">
          <div class="spinner"></div>
          <div class="reconnect-text">Reconnecting...</div>
          <div class="reconnect-attempt" id="reconnectAttempt">Attempt 1</div>
        </div>
        <div class="chat-input-area">
          <div class="queue-indicator" id="queueIndicator">
            <span>ğŸ“¨</span>
            <span class="queue-count" id="queueCount">0</span>
            <span>queued</span>
            <button class="clear-queue" onclick="clearMessageQueue()" title="Clear queue">âœ•</button>
          </div>
          
          <!-- Media preview (shows pending uploads) -->
          <div id="mediaPreviewContainer"></div>
          
          <!-- Hidden file input -->
          <input type="file" id="mediaFileInput" accept="image/*,audio/*" multiple>
          
          <div class="chat-input-wrapper">
            <button class="attach-btn" onclick="document.getElementById('mediaFileInput').click()" title="Attach files">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48"/>
              </svg>
            </button>
            <textarea 
              class="chat-input" 
              id="chatInput" 
              placeholder="Type a message..."
              rows="1"
              onkeydown="handleChatKey(event)"
              oninput="autoResize(this)"
            ></textarea>
            <button class="stop-btn" id="stopBtn" onclick="stopAgent()" disabled title="Stop">â¹</button>
            <button class="voice-btn" id="voiceRecordBtn" title="Record voice" aria-pressed="false">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
              </svg>
            </button>
            <span class="voice-timer" id="voiceTimer">0:00</span>
            <div class="voice-meter" id="voiceMeter">
              <div class="voice-meter-level" id="voiceMeterLevel"></div>
            </div>
            <button class="send-btn" id="sendBtn" onclick="sendMessage()">
              <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
            </button>
          </div>
          <div class="voice-hint" id="voiceHint">Recordingâ€¦ click mic to stop</div>
        </div>
      </div>

      <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SESSION DETAIL PANEL (slides in on right, inside main-content)
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
      <div id="sessionDetailPanel" class="session-detail-panel">
        <div class="detail-panel-header">
          <span class="detail-panel-title" id="detailPanelTitle">Session</span>
          <button class="ghost-btn" onclick="closeDetailPanel()" title="Close panel" style="background:none;border:none;color:var(--text-dim);font-size:1.2rem;cursor:pointer;padding:4px 8px;">âœ•</button>
        </div>
        <div class="detail-panel-body">
          <div class="chat-messages" id="detailChatMessages"></div>
        </div>
        <div id="detailComposerMount"></div>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>
  <!-- Load configuration before main script -->
  <script src="/lib/config.js"></script>
  <script src="/lib/message-shaping.js"></script>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONSTANTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const WS_PROTOCOL_VERSION = 3;
    const RECONNECT_DELAYS = [1000, 2000, 5000, 10000, 30000];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Get configuration (from config.js)
    const config = window.ClawCondosConfig ? window.ClawCondosConfig.getConfig() : {};
    
    const state = {
      // Data
      sessions: [],
      apps: [],
      agents: [],
      goals: [],
      currentGoalOpenId: null,
      attachSessionKey: null,
      attachGoalId: null,
      
      // UI
      currentView: 'overview',
      currentSession: null,
      chatHistory: [],
      isThinking: false,
      messageQueue: [],  // Queued messages when agent is busy
      detailPanelSessionKey: null,  // Session key shown in detail panel

      // Per-session model overrides (UI-level; model switch is triggered by sending /new <model>)
      sessionModelOverrides: (() => {
        try { return JSON.parse(lsGet('session_model_overrides', '{}') || '{}') || {}; } catch { return {}; }
      })(),
      
      // Audio recording
      mediaRecorder: null,
      audioChunks: [],
      recordingStartTime: null,
      recordingTimerInterval: null,
      
      // Multi-select
      multiSelectMode: false,
      selectedSessions: new Set(),
      
      // Auth - loaded from config or localStorage
      // Token should be set via config.json or login modal, NOT hardcoded
      token: localStorage.getItem('sharp_token') || null,
      gatewayUrl: (() => {
        // Priority: localStorage > config > auto-detect
        const saved = localStorage.getItem('sharp_gateway');
        if (saved && !saved.includes(':18789')) {
          return saved;
        }
        // Clear invalid old URLs
        if (saved && saved.includes(':18789') && window.location.hostname !== 'localhost') {
          localStorage.removeItem('sharp_gateway');
        }
        // Use config if available
        if (config.gatewayWsUrl) {
          return config.gatewayWsUrl;
        }
        // Auto-detect from location
        const host = window.location.hostname || 'localhost';
        if (host.includes('.ts.net') && window.location.protocol === 'http:') {
          return 'wss://' + host;
        }
        const proto = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const port = window.location.port;
        return port ? proto + host + ':' + port : proto + host;
      })(),
      
      // WebSocket
      ws: null,
      wsReconnectTimer: null,
      wsKeepaliveTimer: null,
      wsStaleTimer: null,
      wsLastMessageAt: 0,
      wsReconnectAttempts: 0,
      connected: false,
      connectNonce: null,
      connectSent: false,
      rpcIdCounter: 0,
      rpcPending: new Map(),
      
      // Streaming
      activeRuns: new Map(),
      activeRunsStore: JSON.parse(localStorage.getItem('sharp_active_runs') || '{}'),  // Persisted: { sessionKey: { runId, startedAt } }
      sessionInputReady: new Map(),
      
      // Pin
      pinnedSessions: JSON.parse(localStorage.getItem('sharp_pinned_sessions') || '[]'),
      
      // Custom session names
      sessionNames: JSON.parse(localStorage.getItem('sharp_session_names') || '{}'),

      // Per-session UI verbose toggle (best-effort; actual runtime state lives server-side)
      verboseBySession: JSON.parse(localStorage.getItem('sharp_verbose_by_session') || '{}'),
      
      // Search
      searchQuery: '',
      
      // Auto-title generation tracking
      generatingTitles: new Set(),  // Currently generating
      attemptedTitles: new Set(),   // Already tried (avoid retries)
      
      // Goal time filter (sidebar): days to show
      goalTimeFilter: localStorage.getItem('sharp_goal_time_filter') || '7',
      goalPanelOpen: false,
      goalChatSessionKey: null,
      goalTab: 'tasks',
      pendingRouteGoalId: null,
      pendingRouteSessionKey: null,
      pendingRouteDetailKey: null,
      
      // Track when sessions were last viewed (for unread indicator)
      lastViewedAt: JSON.parse(localStorage.getItem('sharp_last_viewed') || '{}'),
      
      // Track which session groups are expanded (for nested view)
      expandedGroups: JSON.parse(localStorage.getItem('sharp_expanded_groups') || '{}'),

      // Track which agent nodes are expanded in sidebar (Agents > Sessions/Subsessions)
      expandedAgents: JSON.parse(localStorage.getItem('sharp_expanded_agents') || '{}'),
      
      // Session status (two separate concepts)
      // 1) Brief current state (LLM-generated text)
      sessionBriefStatus: JSON.parse(localStorage.getItem('sharp_session_brief_status') || '{}'),
      generatingStatus: new Set(),

      // 2) Agent lifecycle status (idle/thinking/offline/error)
      sessionAgentStatus: JSON.parse(localStorage.getItem('sharp_session_agent_status') || '{}'),
      
      // Tool activity tracking (for compact indicator)
      activeTools: new Map(),  // Map<toolCallId, { name, args, output, startedAt, status }>
      toolActivityExpanded: false,

      // Condos
      condos: [],
      condoExpanded: JSON.parse(localStorage.getItem('sharp_condo_expanded') || '{}'),
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION PIN & ARCHIVE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function isSessionPinned(key) {
      return state.pinnedSessions.includes(key);
    }
    
    // Parse session key to extract group info for nesting
    function parseSessionGroup(key) {
      // Match patterns like: agent:main:telegram:group:-1003814943696:topic:54
      const topicMatch = key.match(/^(agent:[^:]+:[^:]+:group:[^:]+):topic:(\d+)$/);
      if (topicMatch) {
        return {
          type: 'topic',
          groupKey: topicMatch[1],
          topicId: topicMatch[2],
          isGrouped: true
        };
      }
      // Match patterns like: agent:main:telegram:group:-1003814943696 (group without topic)
      const groupMatch = key.match(/^(agent:[^:]+:[^:]+:group:[^:]+)$/);
      if (groupMatch) {
        return {
          type: 'group',
          groupKey: groupMatch[1],
          isGrouped: false
        };
      }
      return { type: 'standalone', isGrouped: false };
    }
    
    function getGroupDisplayName(groupKey) {
      // Try to find a custom name for the group
      const customName = state.sessionNames[groupKey];
      if (customName) return customName;
      // Extract group ID and return a readable name
      const match = groupKey.match(/:group:(-?\d+)$/);
      if (match) {
        return `Group ${match[1]}`;
      }
      return groupKey.split(':').pop();
    }
    
    function toggleGroupExpanded(groupKey) {
      state.expandedGroups[groupKey] = !state.expandedGroups[groupKey];
      localStorage.setItem('sharp_expanded_groups', JSON.stringify(state.expandedGroups));
      renderSessions();
    }
    
    function isGroupExpanded(groupKey) {
      // Default to expanded
      return state.expandedGroups[groupKey] !== false;
    }

    function toggleAgentExpanded(agentId) {
      state.expandedAgents[agentId] = !isAgentExpanded(agentId);
      localStorage.setItem('sharp_expanded_agents', JSON.stringify(state.expandedAgents));
      renderAgents();
    }

    function isAgentExpanded(agentId) {
      // Default to expanded
      return state.expandedAgents[agentId] !== false;
    }
    
    function getGroupUnreadCount(groupKey, sessions) {
      return sessions.filter(s => {
        const parsed = parseSessionGroup(s.key);
        return parsed.groupKey === groupKey && isSessionUnread(s.key);
      }).length;
    }
    
    async function generateGroupTitles(groupKey, event) {
      if (event) event.stopPropagation();
      // Find all sessions in this group
      const groupSessions = state.sessions.filter(s => {
        const parsed = parseSessionGroup(s.key);
        return parsed.groupKey === groupKey && parsed.type === 'topic';
      });
      
      showToast(`Generating titles for ${groupSessions.length} topics...`);
      
      // Generate titles for each session that doesn't have a custom name
      for (const s of groupSessions) {
        if (!getCustomSessionName(s.key) && !state.generatingTitles.has(s.key)) {
          await generateSessionTitle(s.key);
          // Small delay between requests
          await new Promise(r => setTimeout(r, 500));
        }
      }
    }
    
    // Session status - brief current state (5-10 words)
    function getSessionStatus(key) {
      return state.sessionBriefStatus[key] || null;
    }
    
    async function generateSessionStatusBrief(key, event) {
      if (event) event.stopPropagation();
      if (state.generatingStatus.has(key)) return;
      
      state.generatingStatus.add(key);
      renderSessions();
      
      try {
        const history = await rpcCall('chat.history', { sessionKey: key, limit: 5 });
        if (!history?.messages?.length) {
          state.generatingStatus.delete(key);
          return;
        }
        
        const context = history.messages
          .filter(m => m.role === 'user' || m.role === 'assistant')
          .map(m => `${m.role}: ${typeof m.content === 'string' ? m.content.slice(0, 150) : ''}`)
          .join('\n');
        
        const response = await fetch('api/openai/v1/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
              { role: 'system', content: 'Write a 5-8 word status of what is currently happening. Be specific. No punctuation. Examples: "Adding unread indicators to ClawCondos sidebar", "Debugging Catastro API rate limits", "Waiting for user feedback on design"' },
              { role: 'user', content: context.slice(0, 1500) }
            ],
            max_tokens: 30,
            temperature: 0.3
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          const status = data.choices?.[0]?.message?.content?.trim();
          if (status && status.length < 80) {
            state.sessionBriefStatus[key] = { text: status, updatedAt: Date.now() };
            localStorage.setItem('sharp_session_brief_status', JSON.stringify(state.sessionBriefStatus));
          }
        }
      } catch (err) {
        console.error('Status generation failed:', err);
      } finally {
        state.generatingStatus.delete(key);
        renderSessions();
      }
    }
    
    // Ask the session agent for a full summary
    async function askSessionForSummary(key, event) {
      if (event) event.stopPropagation();
      
      // Send message to the session asking for summary
      try {
        await rpcCall('chat.send', {
          sessionKey: key,
          message: 'Please give me a clean summary of our full conversation so far - what we discussed, what was accomplished, and current status.',
          idempotencyKey: `summary-request-${Date.now()}`
        });
        
        showToast('Asked session for summary - check the chat');
        // Open that session so user can see the response
        openSession(key);
      } catch (err) {
        console.error('Failed to ask for summary:', err);
        showToast('Failed to request summary', 'error');
      }
    }
    
    function renderSessionStatusLine(key) {
      const isGenerating = state.generatingStatus.has(key);
      const status = getSessionStatus(key);
      
      if (isGenerating) {
        return '<div class="item-status generating">â³</div>';
      }
      
      if (status?.text) {
        return `<div class="item-status" onclick="event.stopPropagation(); generateSessionStatusBrief('${escapeHtml(key)}')" title="Click to refresh">${escapeHtml(status.text)}</div>`;
      }
      
      return `<div class="item-status generate-link" onclick="event.stopPropagation(); generateSessionStatusBrief('${escapeHtml(key)}')">â†» status</div>`;
    }
    
    function isSessionUnread(key) {
      const session = state.sessions.find(s => s.key === key);
      if (!session) return false;
      const lastViewed = state.lastViewedAt[key] || 0;
      const updatedAt = session.updatedAt || 0;
      // Unread if updated since last viewed (with 1s grace period)
      return updatedAt > lastViewed + 1000;
    }
    
    function markSessionRead(key) {
      state.lastViewedAt[key] = Date.now();
      localStorage.setItem('sharp_last_viewed', JSON.stringify(state.lastViewedAt));
    }
    
    function markSessionUnread(key, event) {
      if (event) event.stopPropagation();
      // Set lastViewed to 0 so it appears unread
      state.lastViewedAt[key] = 0;
      localStorage.setItem('sharp_last_viewed', JSON.stringify(state.lastViewedAt));
      renderSessions();
      renderSessionsGrid();
    }
    
    function markAllSessionsRead() {
      const now = Date.now();
      state.sessions.forEach(s => {
        state.lastViewedAt[s.key] = now;
      });
      localStorage.setItem('sharp_last_viewed', JSON.stringify(state.lastViewedAt));
      renderSessions();
      renderSessionsGrid();
      showToast('All sessions marked as read');
    }
    
    function getUnreadCount() {
      return state.sessions.filter(s => isSessionUnread(s.key)).length;
    }
    
    function togglePinSession(key) {
      const idx = state.pinnedSessions.indexOf(key);
      if (idx >= 0) {
        state.pinnedSessions.splice(idx, 1);
      } else {
        state.pinnedSessions.push(key);
      }
      localStorage.setItem('sharp_pinned_sessions', JSON.stringify(state.pinnedSessions));
      renderSessions();
      renderSessionsGrid();
    }
    
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION RENAME
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function getCustomSessionName(key) {
      return state.sessionNames[key] || null;
    }
    
    function setCustomSessionName(key, name) {
      if (name && name.trim()) {
        state.sessionNames[key] = name.trim();
      } else {
        delete state.sessionNames[key];
      }
      localStorage.setItem('sharp_session_names', JSON.stringify(state.sessionNames));
      renderSessions();
      renderSessionsGrid();
    }
    
    function promptRenameSession(key, event) {
      if (event) event.stopPropagation();
      const session = state.sessions.find(s => s.key === key);
      const current = getCustomSessionName(key) || getDefaultSessionName(session);
      const newName = prompt('Rename session:', current);
      if (newName !== null) {
        setCustomSessionName(key, newName);
      }
    }
    
    async function generateSessionTitle(key, event) {
      if (event) event.stopPropagation();
      const session = state.sessions.find(s => s.key === key);
      if (!session) return;
      
      showToast('Generating title...', 'info', 3000);
      
      try {
        // Get first few messages from this session
        const historyResult = await rpcCall('chat.history', { sessionKey: key, limit: 5 });
        const messages = historyResult?.messages || [];
        
        if (messages.length === 0) {
          showToast('No messages to summarize', 'warning');
          return;
        }
        
        // Extract conversation context
        const conversation = messages.slice(0, 4).map(m => {
          const role = m.role === 'user' ? 'User' : 'Assistant';
          let content = '';
          if (typeof m.content === 'string') {
            content = m.content.slice(0, 150);
          } else if (Array.isArray(m.content)) {
            content = m.content
              .filter(c => c.type === 'text')
              .map(c => c.text)
              .join(' ')
              .slice(0, 150);
          }
          return `${role}: ${content}`;
        }).join('\n');
        
        if (!conversation.trim()) {
          showToast('No content to summarize', 'warning');
          return;
        }
        
        // Try LLM-based title generation
        const title = await generateTitleWithLLM(conversation);
        
        if (title) {
          setCustomSessionName(key, title);
          showToast(`Titled: "${title}"`, 'success');
        } else {
          showToast('Could not generate title', 'warning');
        }
      } catch (err) {
        console.error('Failed to generate title:', err);
        showToast('Failed to generate title', 'error');
      }
    }
    
    async function generateTitleWithLLM(conversation) {
      try {
        // Use server-side proxy that injects the API key
        const response = await fetch('api/openai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
              {
                role: 'system',
                content: 'Generate a very short title (3-6 words) for this conversation. Reply with ONLY the title, no quotes, no punctuation at the end.'
              },
              {
                role: 'user',
                content: conversation
              }
            ],
            max_tokens: 20,
            temperature: 0.3
          })
        });
        
        if (!response.ok) {
          console.error('OpenAI API error:', response.status);
          return null;
        }
        
        const data = await response.json();
        const title = data.choices?.[0]?.message?.content?.trim();
        
        if (title && title.length < 60) {
          return title.replace(/^["']|["']$/g, '').replace(/\.+$/, '');
        }
        return null;
      } catch (err) {
        console.error('LLM title generation failed:', err);
        return null;
      }
    }
    
    // OpenAI API key is injected server-side via /api/openai proxy
    
    async function autoGenerateTitle(key) {
      // Mark as attempted to avoid retries
      state.attemptedTitles.add(key);
      state.generatingTitles.add(key);
      renderSessions();
      
      try {
        const session = state.sessions.find(s => s.key === key);
        if (!session) return;
        
        // Get messages
        const historyResult = await rpcCall('chat.history', { sessionKey: key, limit: 5 });
        const messages = historyResult?.messages || [];
        
        if (messages.length === 0) {
          state.generatingTitles.delete(key);
          renderSessions();
          return;
        }
        
        // Extract conversation
        const conversation = messages.slice(0, 4).map(m => {
          const role = m.role === 'user' ? 'User' : 'Assistant';
          let content = '';
          if (typeof m.content === 'string') {
            content = m.content.slice(0, 150);
          } else if (Array.isArray(m.content)) {
            content = m.content
              .filter(c => c.type === 'text')
              .map(c => c.text)
              .join(' ')
              .slice(0, 150);
          }
          return `${role}: ${content}`;
        }).join('\n');
        
        if (!conversation.trim()) {
          state.generatingTitles.delete(key);
          renderSessions();
          return;
        }
        
        // Generate title
        const title = await generateTitleWithLLM(conversation);
        
        state.generatingTitles.delete(key);
        
        if (title) {
          // Animate the title with typewriter effect
          setCustomSessionName(key, title);
          animateTitle(key, title);
        } else {
          renderSessions();
        }
      } catch (err) {
        console.error('Auto-generate title failed:', err);
        state.generatingTitles.delete(key);
        renderSessions();
      }
    }
    
    function animateTitle(key, title) {
      // Find the session name element and animate it
      const el = document.querySelector(`[data-session-key="${key}"] .item-name`);
      if (el) {
        el.innerHTML = '';
        el.className = 'item-name title-typewriter';
        let i = 0;
        const interval = setInterval(() => {
          if (i < title.length) {
            el.textContent += title[i];
            i++;
          } else {
            clearInterval(interval);
            el.className = 'item-name';
          }
        }, 30);
      } else {
        renderSessions();
      }
    }
    
    function matchesSearch(session) {
      if (state.searchQuery) {
        const q = state.searchQuery;
        const name = getSessionName(session).toLowerCase();
        const key = session.key.toLowerCase();
        if (!name.includes(q) && !key.includes(q)) return false;
      }
      return true;
    }
    
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TOAST NOTIFICATIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showToast(message, type = 'info', durationMs = 4000) {
      const container = document.getElementById('toastContainer');
      if (!container) return;
      
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const icon = type === 'success' ? 'âœ“' : type === 'warning' ? 'âš ' : 'â„¹';
      toast.innerHTML = `<span>${icon}</span><span>${escapeHtml(message)}</span>`;
      
      container.appendChild(toast);
      
      // Auto-remove after duration
      setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => toast.remove(), 300);
      }, durationMs);
    }
    
    async function copyToClipboard(text) {
      await navigator.clipboard.writeText(text);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEBSOCKET CONNECTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function connectWebSocket() {
      if (state.ws) {
        state.ws.close();
        state.ws = null;
      }
      
      state.connectNonce = null;
      state.connectSent = false;
      setConnectionStatus('connecting');
      
      // Build WebSocket URL - use /ws path for Caddy proxy
      let wsUrl = state.gatewayUrl.replace(/^http/, 'ws');
      // If connecting through Caddy (port 9000 or no port), use /ws endpoint
      if (!wsUrl.includes(':18789')) {
        wsUrl = wsUrl.replace(/\/?$/, '/ws');
      }
      console.log('[WS] Connecting to', wsUrl);
      
      try {
        state.ws = new WebSocket(wsUrl);
      } catch (err) {
        console.error('[WS] Failed to create WebSocket:', err);
        setConnectionStatus('error');
        scheduleReconnect();
        return;
      }
      
      state.ws.onopen = () => {
        console.log('[WS] Socket opened, waiting for challenge...');
        state.wsLastMessageAt = Date.now();
      };
      
      state.ws.onmessage = (event) => {
        state.wsLastMessageAt = Date.now();
        resetStaleTimer();
        
        try {
          const msg = JSON.parse(event.data);
          handleWsMessage(msg);
        } catch (err) {
          console.error('[WS] Parse error:', err);
        }
      };
      
      state.ws.onerror = (err) => {
        console.error('[WS] Error:', err);
      };
      
      state.ws.onclose = (event) => {
        console.log('[WS] Closed:', event.code, event.reason);
        state.connected = false;
        state.ws = null;
        state.connectNonce = null;
        state.connectSent = false;
        clearWsTimers();
        setConnectionStatus('error');
        
        for (const [id, pending] of state.rpcPending) {
          clearTimeout(pending.timeout);
          pending.reject(new Error('WebSocket closed'));
        }
        state.rpcPending.clear();
        
        scheduleReconnect();
      };
    }
    
    function handleWsMessage(msg) {
      // Debug: log all incoming messages
      if (msg.type === 'event') {
        console.log('[ClawCondos] WS Event:', msg.event, msg.payload ? JSON.stringify(msg.payload).slice(0, 200) : '');
      }
      
      // Challenge for auth (comes as event type)
      if (msg.type === 'event' && msg.event === 'connect.challenge') {
        state.connectNonce = msg.payload?.nonce;
        // Auto-connect (password hardcoded for Tailscale-only access)
        sendConnect();
        return;
      }
      
      // RPC response
      if (msg.type === 'res' && msg.id) {
        const pending = state.rpcPending.get(msg.id);
        if (pending) {
          state.rpcPending.delete(msg.id);
          clearTimeout(pending.timeout);
          
          if (msg.error) {
            pending.reject(new Error(msg.error?.message || 'RPC failed'));
          } else {
            pending.resolve(msg.payload ?? msg.result);
          }
        }
        return;
      }
      
      // Chat events (streaming)
      if (msg.type === 'event' && msg.event === 'chat') {
        handleChatEvent(msg.payload);
        return;
      }
      
      // Agent lifecycle events (for typing indicator)
      if (msg.type === 'event' && msg.event === 'agent') {
        handleAgentEvent(msg.payload);
        return;
      }
    }
    
    function sendConnect() {
      if (state.connectSent || !state.ws) return;
      state.connectSent = true;
      
      const connectId = String(++state.rpcIdCounter);
      
      const connectParams = {
        minProtocol: WS_PROTOCOL_VERSION,
        maxProtocol: WS_PROTOCOL_VERSION,
        client: {
          id: 'openclaw-control-ui',
          displayName: 'ClawCondos Dashboard',
          mode: 'ui',
          version: '2.0.0',
          platform: 'browser'
        }
      };
      
      // Only include auth if we have a token/password
      // NOTE: OpenClaw Gateway can use token or password auth depending on config.
      if (state.token) {
        connectParams.auth = { password: state.token };
      }
      
      const connectFrame = {
        type: 'req',
        id: connectId,
        method: 'connect',
        params: connectParams
      };
      
      console.log('[WS] Sending connect request');
      state.ws.send(JSON.stringify(connectFrame));
      
      const timeout = setTimeout(() => {
        state.rpcPending.delete(connectId);
        console.error('[WS] Connect timeout');
        state.ws?.close(1008, 'connect timeout');
      }, 10000);
      
      state.rpcPending.set(connectId, {
        resolve: (result) => {
          console.log('[WS] Connected successfully');
          state.connected = true;
          state.wsReconnectAttempts = 0;
          setConnectionStatus('connected');
          hideReconnectOverlay();
          localStorage.setItem('sharp_token', state.token);
          localStorage.setItem('sharp_gateway', state.gatewayUrl);
          hideLoginModal();
          startKeepalive();
          loadInitialData();
        },
        reject: (err) => {
          console.error('[WS] Connect failed:', err);
          state.connectSent = false;
          setConnectionStatus('error');
          showLoginModal();
          const errorDiv = document.getElementById('loginError');
          if (errorDiv) {
            errorDiv.textContent = err.message || 'Authentication failed';
            errorDiv.style.display = 'block';
          }
        },
        timeout
      });
    }
    
    function handleAgentEvent(data) {
      const { sessionKey, runId, stream, data: eventData } = data;
      
      // Show typing indicator when agent starts working
      if (stream === 'lifecycle' && eventData?.phase === 'start') {
        if (state.currentSession?.key === sessionKey) {
          showTypingIndicator(runId);
        }
        // Also set thinking status
        trackActiveRun(sessionKey, runId);
        state.sessionInputReady.set(sessionKey, false);
        if (state.sessionAgentStatus[sessionKey] !== 'thinking') {
          setSessionStatus(sessionKey, 'thinking');
        }
      }
      
      // Hide typing indicator when agent ends
      if (stream === 'lifecycle' && eventData?.phase === 'end') {
        hideTypingIndicator(runId);
      }
      
      // Show tool calls via compact activity indicator
      if (stream === 'tool' && state.currentSession?.key === sessionKey) {
        const toolCallId = eventData?.toolCallId || `${runId}-${eventData?.name}-${Date.now()}`;
        const toolName = eventData?.name || eventData?.tool || 'tool';
        const toolInput = eventData?.input || eventData?.args || '';
        const toolOutput = eventData?.output || eventData?.result || '';
        
        if (eventData?.phase === 'start' || eventData?.type === 'call') {
          trackToolStart(runId, toolCallId, toolName, toolInput);
        } else if (eventData?.phase === 'end' || eventData?.phase === 'result' || eventData?.type === 'result') {
          trackToolEnd(runId, toolCallId, toolName, toolOutput);
          if (GOAL_TOOL_NAMES.has(toolName)) debouncedGoalRefresh();
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPACT TOOL ACTIVITY INDICATOR
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function getToolIcon(toolName) {
      const name = (toolName || '').toLowerCase();
      if (name.includes('read') || name.includes('file')) return 'ğŸ“„';
      if (name.includes('write') || name.includes('edit')) return 'âœï¸';
      if (name.includes('exec') || name.includes('bash') || name.includes('shell')) return 'âš¡';
      if (name.includes('browser') || name.includes('web')) return 'ğŸŒ';
      if (name.includes('search')) return 'ğŸ”';
      if (name.includes('image')) return 'ğŸ–¼ï¸';
      if (name.includes('message') || name.includes('send')) return 'ğŸ’¬';
      if (name.includes('cron') || name.includes('schedule')) return 'â°';
      if (name.includes('memory')) return 'ğŸ§ ';
      return 'ğŸ”§';
    }
    
    function trackToolStart(runId, toolCallId, toolName, input) {
      hideTypingIndicator(runId);
      
      state.activeTools.set(toolCallId, {
        runId,
        name: toolName,
        args: input,
        output: null,
        startedAt: Date.now(),
        status: 'running'
      });
      
      renderToolActivity();
      scrollChatToBottom();
    }
    
    function trackToolEnd(runId, toolCallId, toolName, output) {
      // Find by toolCallId or by name (fallback)
      let tool = state.activeTools.get(toolCallId);
      if (!tool) {
        // Fallback: find most recent tool with same name
        for (const [id, t] of state.activeTools) {
          if (t.name === toolName && t.status === 'running') {
            toolCallId = id;
            tool = t;
            break;
          }
        }
      }
      
      if (tool) {
        tool.output = output;
        tool.status = 'done';
        tool.endedAt = Date.now();
        state.activeTools.set(toolCallId, tool);
      }
      
      renderToolActivity();
      
      // Clear completed tools after a delay (keep them visible briefly)
      setTimeout(() => {
        cleanupCompletedTools(runId);
      }, 3000);
    }
    
    function cleanupCompletedTools(runId) {
      // Only clean up if all tools for this run are done
      let allDone = true;
      for (const [id, tool] of state.activeTools) {
        if (tool.runId === runId && tool.status === 'running') {
          allDone = false;
          break;
        }
      }
      
      if (allDone) {
        // Remove all tools for this run
        for (const [id, tool] of state.activeTools) {
          if (tool.runId === runId) {
            state.activeTools.delete(id);
          }
        }
        renderToolActivity();
      }
    }
    
    function clearAllTools() {
      state.activeTools.clear();
      state.toolActivityExpanded = false;
      const el = document.getElementById('toolActivityIndicator');
      if (el) el.remove();
    }
    
    function toggleToolActivityExpanded() {
      state.toolActivityExpanded = !state.toolActivityExpanded;
      const el = document.getElementById('toolActivityIndicator');
      if (el) {
        el.classList.toggle('expanded', state.toolActivityExpanded);
      }
    }
    
    function renderToolActivity() {
      const container = document.getElementById('chatMessages');
      if (!container) return;
      
      let el = document.getElementById('toolActivityIndicator');
      
      // If no active tools, remove the indicator
      if (state.activeTools.size === 0) {
        if (el) el.remove();
        return;
      }
      
      // Count running vs done
      let runningCount = 0;
      let doneCount = 0;
      const tools = Array.from(state.activeTools.values());
      tools.forEach(t => t.status === 'running' ? runningCount++ : doneCount++);
      
      // Build pills HTML
      const pillsHtml = tools.slice(-5).map(t => {
        const icon = getToolIcon(t.name);
        const statusClass = t.status === 'done' ? 'done' : '';
        return `<span class="tool-activity-pill ${statusClass}">
          <span class="pill-icon">${icon}</span>
          <span>${escapeHtml(t.name)}</span>
        </span>`;
      }).join('');
      
      // Build details HTML
      const detailsHtml = tools.map(t => {
        const icon = getToolIcon(t.name);
        const statusClass = t.status === 'running' ? 'running' : 'done';
        const statusText = t.status === 'running' ? 'â³ running' : 'âœ“ done';
        const argsStr = t.args ? (typeof t.args === 'string' ? t.args : JSON.stringify(t.args, null, 2)) : '';
        const outputStr = t.output ? (typeof t.output === 'string' ? t.output : JSON.stringify(t.output, null, 2)) : '';
        const contentStr = outputStr ? `${argsStr}\n\n--- Result ---\n${outputStr}` : argsStr;
        
        return `<div class="tool-activity-item">
          <div class="tool-activity-item-header">
            <span class="tool-activity-item-icon">${icon}</span>
            <span class="tool-activity-item-name">${escapeHtml(t.name)}</span>
            <span class="tool-activity-item-status ${statusClass}">${statusText}</span>
          </div>
          ${contentStr ? `<div class="tool-activity-item-content collapsed">${escapeHtml(contentStr)}</div>` : ''}
        </div>`;
      }).join('');
      
      const labelText = runningCount > 0 
        ? `Working... (${runningCount} active${doneCount > 0 ? `, ${doneCount} done` : ''})`
        : `${doneCount} tool${doneCount !== 1 ? 's' : ''} completed`;
      
      const showSpinner = runningCount > 0;
      
      if (!el) {
        el = document.createElement('div');
        el.id = 'toolActivityIndicator';
        el.className = 'tool-activity';
        container.appendChild(el);
      }
      
      if (state.toolActivityExpanded) {
        el.classList.add('expanded');
      }
      
      el.innerHTML = `
        <div class="tool-activity-header" onclick="toggleToolActivityExpanded()">
          ${showSpinner ? '<div class="tool-activity-spinner"></div>' : '<span style="color: var(--green);">âœ“</span>'}
          <span class="tool-activity-label">${labelText}</span>
          <div class="tool-activity-tools">${pillsHtml}</div>
          <span class="tool-activity-expand">â–¼</span>
        </div>
        <div class="tool-activity-details">${detailsHtml}</div>
      `;
      
      scrollChatToBottom();
    }
    
    // Legacy function for compatibility - now uses compact indicator
    function addToolCall(runId, toolName, input) {
      const toolCallId = `${runId}-${toolName}-${Date.now()}`;
      trackToolStart(runId, toolCallId, toolName, input);
    }
    
    function updateToolCallResult(runId, toolName, output) {
      // Find most recent tool with this name
      for (const [id, tool] of state.activeTools) {
        if (tool.name === toolName && tool.status === 'running') {
          trackToolEnd(runId, id, toolName, output);
          return;
        }
      }
      // Fallback: legacy behavior
      const toolCalls = document.querySelectorAll('.tool-call');
      for (let i = toolCalls.length - 1; i >= 0; i--) {
        const nameEl = toolCalls[i].querySelector('.tool-call-name');
        if (nameEl && nameEl.textContent === toolName) {
          const contentEl = toolCalls[i].querySelector('.tool-call-content pre');
          if (contentEl) {
            const outputStr = typeof output === 'string' ? output : JSON.stringify(output, null, 2);
            contentEl.textContent += '\n\n--- Result ---\n' + outputStr;
          }
          break;
        }
      }
    }
    
    function handleChatEvent(data) {
      const { sessionKey, runId, state: runState, message } = data;
      
      console.log('[ClawCondos] Chat event:', runState, 'for', sessionKey, 'runId:', runId);
      
      // Server sends: 'delta' (streaming), 'final' (done), 'error'
      // Track active runs and update agent status (with persistence)
      if (runState === 'delta') {
        // Streaming chunk - agent is thinking/responding
        trackActiveRun(sessionKey, runId);
        state.sessionInputReady.set(sessionKey, false);
        if (state.sessionAgentStatus[sessionKey] !== 'thinking') {
          setSessionStatus(sessionKey, 'thinking');
        }
        
        // Show streaming content in current session
        if (state.currentSession?.key === sessionKey && message?.content) {
          const text = extractText(message.content);
          if (text) {
            updateStreamingMessage(runId, text);
          }
        }
      } else if (runState === 'final') {
        // Response complete
        clearActiveRun(sessionKey);
        state.sessionInputReady.set(sessionKey, true);
        setSessionStatus(sessionKey, 'idle');
        
        // Check if this is a categorization/wizard response (from main session)
        if (sessionKey === 'agent:main:main' && message?.content) {
          const text = extractText(message.content);
          if (text) {
            // Check wizard first
            if (state.wizardPendingSessionKey && text.includes('"goalId"')) {
              handleWizardResponse(text);
            }
            // Check single-session categorization
            else if (state.suggestingSessionKey && text.includes('"suggestions"')) {
              handleCategorizationResponse(text);
            }
          }
        }
        
        if (state.currentSession?.key === sessionKey) {
          state.isThinking = false;
          updateSendButton();
          
          // Clear tool activity indicator after brief delay
          setTimeout(() => clearAllTools(), 2000);
          
          // Finalize streaming message or add new one
          if (message?.content) {
            const text = extractText(message.content);
            if (text) {
              finalizeStreamingMessage(runId, text);
            }
          } else {
            // No content in final, just remove thinking indicator
            removeStreamingMessage(runId);
          }
        }
      } else if (runState === 'error' || runState === 'aborted') {
        clearActiveRun(sessionKey);
        state.sessionInputReady.set(sessionKey, true);
        setSessionStatus(sessionKey, runState === 'error' ? 'error' : 'idle');

        if (state.currentSession?.key === sessionKey) {
          state.isThinking = false;
          updateSendButton();
          removeStreamingMessage(runId);
          clearAllTools();  // Clear tool activity on error/abort
          if (data.errorMessage) {
            addChatMessage('system', `Error: ${data.errorMessage}`);
          }
        }
      }

      // Refresh detail panel if it's showing this session
      if (state.detailPanelSessionKey === sessionKey && (runState === 'final' || runState === 'error')) {
        openDetailPanel(sessionKey, { fromRouter: true });
      }
      // Refresh goal chat if it's showing this session
      if (state.goalChatSessionKey === sessionKey && (runState === 'final' || runState === 'error')) {
        renderGoalChat();
      }
    }
    
    // Typing indicator (bouncing dots)
    function showTypingIndicator(runId) {
      // Don't show if already have streaming content
      if (document.getElementById(`streaming-${runId}`)) return;
      
      let el = document.getElementById(`typing-${runId}`);
      if (el) return; // Already showing
      
      const container = document.getElementById('chatMessages');
      if (!container) return;
      
      el = document.createElement('div');
      el.id = `typing-${runId}`;
      el.className = 'typing-indicator';
      el.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
      container.appendChild(el);
      scrollChatToBottom();
    }
    
    function hideTypingIndicator(runId) {
      const el = document.getElementById(`typing-${runId}`);
      if (el) el.remove();
    }
    
    // Streaming message management
    function updateStreamingMessage(runId, text) {
      // Hide typing indicator when content arrives
      hideTypingIndicator(runId);
      
      let el = document.getElementById(`streaming-${runId}`);
      if (!el) {
        // Remove old thinking indicator
        const thinking = document.querySelector('.message.thinking');
        if (thinking) thinking.remove();
        
        // Create streaming message element
        const container = document.getElementById('chatMessages');
        el = document.createElement('div');
        el.id = `streaming-${runId}`;
        el.className = 'message assistant streaming';
        el.dataset.startTime = Date.now();
        container.appendChild(el);
      }
      el.innerHTML = `<div class="message-content">${formatMessage(text)}<span class="streaming-cursor">â–Š</span></div>`;
      scrollChatToBottom();
    }
    
    function finalizeStreamingMessage(runId, text) {
      const el = document.getElementById(`streaming-${runId}`);
      if (el) {
        el.classList.remove('streaming');
        const timeStr = formatMessageTime(new Date());
        el.innerHTML = `<div class="message-content">${formatMessage(text)}</div><div class="message-time">${timeStr}</div>`;
      } else if (text) {
        // No streaming element, add final message
        const thinking = document.querySelector('.message.thinking');
        if (thinking) thinking.remove();
        addChatMessage('assistant', text);
      }
    }
    
    function removeStreamingMessage(runId) {
      const el = document.getElementById(`streaming-${runId}`);
      if (el) el.remove();
      hideTypingIndicator(runId);
      const thinking = document.querySelector('.message.thinking');
      if (thinking) thinking.remove();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RPC
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function rpcCall(method, params = {}, timeoutMs = 30000) {
      return new Promise((resolve, reject) => {
        if (!state.connected || !state.ws) {
          reject(new Error('WebSocket not connected'));
          return;
        }
        
        const id = String(++state.rpcIdCounter);
        const frame = { type: 'req', id, method, params };
        
        const timeout = setTimeout(() => {
          state.rpcPending.delete(id);
          reject(new Error('RPC timeout'));
        }, timeoutMs);
        
        state.rpcPending.set(id, { resolve, reject, timeout });
        state.ws.send(JSON.stringify(frame));
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TIMERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function clearWsTimers() {
      if (state.wsReconnectTimer) {
        clearTimeout(state.wsReconnectTimer);
        state.wsReconnectTimer = null;
      }
      if (state.wsKeepaliveTimer) {
        clearInterval(state.wsKeepaliveTimer);
        state.wsKeepaliveTimer = null;
      }
      if (state.wsStaleTimer) {
        clearTimeout(state.wsStaleTimer);
        state.wsStaleTimer = null;
      }
    }
    
    function scheduleReconnect() {
      if (state.wsReconnectTimer) return;
      
      const delay = RECONNECT_DELAYS[Math.min(state.wsReconnectAttempts, RECONNECT_DELAYS.length - 1)];
      state.wsReconnectAttempts++;
      
      // Show reconnect overlay
      showReconnectOverlay(state.wsReconnectAttempts);
      
      console.log(`[WS] Reconnecting in ${delay}ms (attempt ${state.wsReconnectAttempts})`);
      state.wsReconnectTimer = setTimeout(() => {
        state.wsReconnectTimer = null;
        connectWebSocket();
      }, delay);
    }
    
    function showReconnectOverlay(attempt) {
      const overlay = document.getElementById('reconnectOverlay');
      const attemptEl = document.getElementById('reconnectAttempt');
      if (overlay) {
        overlay.classList.add('visible');
        if (attemptEl) attemptEl.textContent = `Attempt ${attempt}`;
      }
    }
    
    function hideReconnectOverlay() {
      const overlay = document.getElementById('reconnectOverlay');
      if (overlay) overlay.classList.remove('visible');
    }
    
    function startKeepalive() {
      if (state.wsKeepaliveTimer) clearInterval(state.wsKeepaliveTimer);
      
      state.wsKeepaliveTimer = setInterval(() => {
        if (state.connected && state.ws) {
          state.ws.send(JSON.stringify({ type: 'req', id: 'keepalive', method: 'status', params: {} }));
        }
      }, 25000);
    }
    
    function resetStaleTimer() {
      if (state.wsStaleTimer) clearTimeout(state.wsStaleTimer);
      
      state.wsStaleTimer = setTimeout(() => {
        const sinceLastMessage = Date.now() - state.wsLastMessageAt;
        if (sinceLastMessage > 60000) {
          console.log('[WS] Connection stale, reconnecting...');
          state.ws?.close(1000, 'stale');
        }
      }, 65000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECTION STATUS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function setConnectionStatus(status) {
      const dot = document.getElementById('connectionDot');
      const text = document.getElementById('connectionText');
      
      switch (status) {
        case 'connected':
          dot.style.background = 'var(--green)';
          dot.title = 'Connected to gateway';
          text.textContent = 'Connected';
          // Clear offline status for all sessions when reconnected
          for (const key of Object.keys(state.sessionAgentStatus)) {
            if (state.sessionAgentStatus[key] === 'offline') {
              state.sessionAgentStatus[key] = 'idle';
            }
          }
          break;
        case 'connecting':
          dot.style.background = 'var(--yellow)';
          dot.title = 'Connecting to gateway...';
          text.textContent = 'Connecting...';
          break;
        case 'error':
          dot.style.background = 'var(--red)';
          dot.title = 'Disconnected from gateway';
          text.textContent = 'Disconnected';
          // Set all sessions to offline when disconnected
          for (const key of Object.keys(state.sessionAgentStatus)) {
            state.sessionAgentStatus[key] = 'offline';
          }
          renderSessions();
          updateHeaderStatus();
          break;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AGENT STATUS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Persist active runs to localStorage so we can restore on page load
    const ACTIVE_RUN_STALE_MS = 5 * 60 * 1000; // 5 minutes - consider run stale if no updates
    
    function saveActiveRuns() {
      const obj = {};
      for (const [key, data] of Object.entries(state.activeRunsStore)) {
        obj[key] = data;
      }
      localStorage.setItem('sharp_active_runs', JSON.stringify(obj));
    }
    
    function restoreActiveRuns() {
      // Restore from localStorage and clean stale entries
      const now = Date.now();
      const store = state.activeRunsStore;
      let changed = false;
      
      for (const [key, data] of Object.entries(store)) {
        const age = now - (data.startedAt || 0);
        if (age > ACTIVE_RUN_STALE_MS) {
          // Stale run - remove it
          delete store[key];
          changed = true;
          console.log(`[ClawCondos] Cleaned stale run for ${key} (${Math.round(age/1000)}s old)`);
        } else {
          // Valid run - restore to activeRuns Map
          state.activeRuns.set(key, data.runId);
          state.sessionAgentStatus[key] = 'thinking';
          console.log(`[ClawCondos] Restored active run for ${key}`);
        }
      }
      
      if (changed) {
        saveActiveRuns();
      }
    }
    
    function trackActiveRun(sessionKey, runId) {
      state.activeRuns.set(sessionKey, runId);
      state.activeRunsStore[sessionKey] = { runId, startedAt: Date.now() };
      saveActiveRuns();
    }
    
    function clearActiveRun(sessionKey) {
      state.activeRuns.delete(sessionKey);
      delete state.activeRunsStore[sessionKey];
      saveActiveRuns();
    }
    
    function setSessionStatus(key, status) {
      state.sessionAgentStatus[key] = status;
      localStorage.setItem('sharp_session_agent_status', JSON.stringify(state.sessionAgentStatus));
      renderSessions();
      renderSessionsGrid();
      updateHeaderStatus();
    }
    
    function getAgentStatus(key) {
      return state.sessionAgentStatus[key] || 'idle';
    }
    
    function getStatusTooltip(status) {
      switch (status) {
        case 'idle': return 'Ready';
        case 'thinking': return 'Processing...';
        case 'error': return 'Last request failed';
        case 'offline': return 'Disconnected';
        default: return status;
      }
    }
    
    function updateHeaderStatus() {
      const indicator = document.getElementById('headerStatusIndicator');
      if (!indicator || !state.currentSession) return;
      
      const status = getAgentStatus(state.currentSession.key);
      indicator.className = 'header-status ' + status;
      indicator.setAttribute('data-tooltip', getStatusTooltip(status));
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOGIN
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showLoginModal() {
      document.getElementById('loginModal').classList.remove('hidden');
      document.getElementById('loginPassword').focus();
    }
    
    function hideLoginModal() {
      document.getElementById('loginModal').classList.add('hidden');
      document.getElementById('loginError').style.display = 'none';
    }
    
    function doLogin() {
      const password = document.getElementById('loginPassword').value.trim();
      if (!password) return;
      
      state.token = password;
      state.connectSent = false;
      
      // Save to localStorage for future sessions
      localStorage.setItem('sharp_token', password);
      
      if (state.ws && state.connectNonce) {
        sendConnect();
      } else {
        connectWebSocket();
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DATA LOADING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function loadInitialData() {
      console.log('[ClawCondos] loadInitialData starting');
      try {
        // Fetch active runs from server first (authoritative source)
        console.log('[ClawCondos] About to call syncActiveRunsFromServer...');
        await syncActiveRunsFromServer();
        console.log('[ClawCondos] syncActiveRunsFromServer completed');
        await Promise.all([loadCondos(), loadGoals(), loadSessions(), loadApps(), loadAgents()]);
        updateOverview();
        updateStatsGrid();

        // Route from hash or restore saved session
        var hasRoute = window.location.hash && window.location.hash !== '#/' && window.location.hash !== '#';
        if (hasRoute) {
          handleRoute();
        } else {
          // Fall back to localStorage session restore
          var savedSessionKey = localStorage.getItem('sharp_current_session');
          if (savedSessionKey) {
            var session = state.sessions.find(function(s) { return s.key === savedSessionKey; });
            if (session) {
              console.log('[ClawCondos] Restoring session:', savedSessionKey);
              openSession(savedSessionKey);
            }
          }
        }

        // Handle deferred routes (data wasn't loaded when route was first parsed)
        if (state.pendingRouteGoalId) {
          var gid = state.pendingRouteGoalId;
          state.pendingRouteGoalId = null;
          openGoal(gid, { fromRouter: true });
        }
        if (state.pendingRouteSessionKey) {
          var sk = state.pendingRouteSessionKey;
          state.pendingRouteSessionKey = null;
          var s = state.sessions.find(function(x) { return x.key === sk; });
          if (s) openSession(sk, { fromRouter: true });
        }
        if (state.pendingRouteDetailKey) {
          var dk = state.pendingRouteDetailKey;
          state.pendingRouteDetailKey = null;
          var ds = state.sessions.find(function(x) { return x.key === dk; });
          if (ds) openDetailPanel(dk, { fromRouter: true });
        }
      } catch (err) {
        console.error('Failed to load initial data:', err);
      }
    }
    
    async function syncActiveRunsFromServer() {
      try {
        console.log('[ClawCondos] Calling chat.activeRuns...');
        const result = await rpcCall('chat.activeRuns', {});
        console.log('[ClawCondos] chat.activeRuns response:', JSON.stringify(result));
        if (result?.activeRuns) {
          console.log('[ClawCondos] Synced active runs from server:', result.activeRuns.length);
          
          // Clear old state and sync with server
          state.activeRuns.clear();
          state.activeRunsStore = {};
          
          for (const run of result.activeRuns) {
            console.log('[ClawCondos] Setting thinking for:', run.sessionKey);
            state.activeRuns.set(run.sessionKey, run.runId);
            state.activeRunsStore[run.sessionKey] = {
              runId: run.runId,
              startedAt: run.startedAtMs
            };
            state.sessionAgentStatus[run.sessionKey] = 'thinking';
          }
          
          saveActiveRuns();
          renderSessions();
          renderSessionsGrid();
        } else {
          console.log('[ClawCondos] No activeRuns in response, result:', result);
        }
      } catch (err) {
        console.error('[ClawCondos] chat.activeRuns error:', err);
        // Fallback to localStorage restore (for older Clawdbot versions)
        restoreActiveRuns();
      }
    }
    
    async function loadGoals() {
      try {
        const data = await rpcCall('goals.list', {});
        state.goals = data?.goals || [];
      } catch (err) {
        console.warn('[ClawCondos] Failed to load goals:', err);
      }
      renderGoals();
      renderCondoStatusBoard();
      updateUncategorizedCount();
    }

    async function loadCondos() {
      try {
        const data = await rpcCall('condos.list', {});
        state.condos = data?.condos || [];
      } catch (err) {
        console.warn('[ClawCondos] Failed to load condos:', err);
      }
    }

    function groupGoalsByCondoId() {
      const grouped = {};
      const uncategorized = [];
      for (const g of state.goals) {
        if (g.condoId) {
          if (!grouped[g.condoId]) grouped[g.condoId] = [];
          grouped[g.condoId].push(g);
        } else {
          uncategorized.push(g);
        }
      }
      return { grouped, uncategorized };
    }

    function getCondoAttention(condo, goals) {
      let worst = 'none';
      const priority = { 'none': 0, 'done': 1, 'read': 2, 'unread': 3, 'needs-input': 4 };
      for (const g of goals) {
        const att = getGoalAttention(g);
        if ((priority[att] || 0) > (priority[worst] || 0)) worst = att;
      }
      return worst;
    }

    function getCondoLatestActivity(condo, goals) {
      let latest = condo?.updatedAtMs || condo?.createdAtMs || 0;
      for (const g of goals) {
        const t = getGoalLatestActivity(g);
        if (t > latest) latest = t;
      }
      return latest;
    }

    function toggleCondoExpanded(condoId) {
      state.condoExpanded[condoId] = !state.condoExpanded[condoId];
      localStorage.setItem('sharp_condo_expanded', JSON.stringify(state.condoExpanded));
      renderGoals();
    }

    function updateUncategorizedCount() {
      const el = document.getElementById('uncategorizedCount');
      if (!el) return;
      
      const sessions = (state.sessions || []).filter(s => !s.key.includes(':subagent:'));
      const goals = state.goals || [];
      
      const assignedSessions = new Set();
      goals.forEach(g => (g.sessions || []).forEach(s => assignedSessions.add(s)));
      const uncatCount = sessions.filter(s => !assignedSessions.has(s.key)).length;
      
      if (uncatCount > 0) {
        el.textContent = `${uncatCount} uncategorized`;
      } else {
        el.textContent = '';
      }
    }

    // Update stats grid with current counts
    function updateStatsGrid() {
      const sessions = state.sessions || [];
      const goals = state.goals || [];
      const runs = state.runs || {};
      
      // Active sessions: sessions with recent activity or active runs
      const activeRuns = Object.keys(runs).filter(k => runs[k] && runs[k] !== 'done');
      const activeSessions = activeRuns.length;
      
      // Pending goals: goals with status !== 'done'
      const pendingGoals = goals.filter(g => g.status !== 'done').length;
      
      // Completed goals
      const completedGoals = goals.filter(g => g.status === 'done').length;
      
      // Errors: sessions with error state
      const errorCount = sessions.filter(s => s.lastError || (runs[s.key] && runs[s.key] === 'error')).length;
      
      // Update DOM
      const elActive = document.getElementById('statActiveSessions');
      const elTrend = document.getElementById('statSessionsTrend');
      const elPending = document.getElementById('statPendingGoals');
      const elCompleted = document.getElementById('statCompletedGoals');
      const elErrors = document.getElementById('statErrors');
      
      if (elActive) elActive.textContent = activeSessions;
      if (elTrend) {
        const totalSessions = sessions.filter(s => !s.key.includes(':subagent:')).length;
        elTrend.textContent = totalSessions > 0 ? `${totalSessions} total` : '';
      }
      if (elPending) elPending.textContent = pendingGoals;
      if (elCompleted) elCompleted.textContent = completedGoals;
      if (elErrors) {
        elErrors.textContent = errorCount;
        elErrors.classList.toggle('stat-error', errorCount > 0);
      }
    }

    // Scroll to a section by element ID
    function scrollToSection(sectionId) {
      const el = document.getElementById(sectionId);
      if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    // Filter goals grid by status (pending/done)
    function filterGoalsByStatus(status) {
      scrollToSection('recentActivitySection');
      showToast(`Showing ${status === 'done' ? 'completed' : 'pending'} goals`, 'info');
    }

    // Show sessions with errors
    function showErrorSessions() {
      const sessions = state.sessions || [];
      const runs = state.runs || {};
      const errorSessions = sessions.filter(s => s.lastError || (runs[s.key] && runs[s.key] === 'error'));

      if (errorSessions.length === 0) {
        showToast('No sessions with errors', 'info');
        return;
      }

      scrollToSection('recentActivitySection');
      showToast(`${errorSessions.length} session(s) with errors`, 'error');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GOAL ATTENTION & TIME FILTER HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function getGoalLatestSession(goal) {
      if (!Array.isArray(goal.sessions) || !goal.sessions.length) return null;
      let best = null;
      let bestTime = 0;
      for (const key of goal.sessions) {
        const s = state.sessions.find(x => x.key === key);
        if (s && (s.updatedAt || 0) > bestTime) {
          best = s;
          bestTime = s.updatedAt || 0;
        }
      }
      return best;
    }

    function getGoalLatestActivity(goal) {
      const latest = getGoalLatestSession(goal);
      return latest ? (latest.updatedAt || 0) : (goal.updatedAtMs || goal.createdAtMs || 0);
    }

    function getGoalAttention(goal) {
      if (goal.status === 'done') return 'done';
      const latest = getGoalLatestSession(goal);
      if (!latest) return 'none';
      if (!isSessionUnread(latest.key)) return 'read';
      const agentStatus = getAgentStatus(latest.key);
      if (agentStatus === 'idle' || agentStatus === 'error') return 'needs-input';
      return 'unread';
    }

    function setGoalTimeFilter(value) {
      state.goalTimeFilter = value;
      localStorage.setItem('sharp_goal_time_filter', value);
      renderGoals();
    }

    function initGoalTimeFilterUI() {
      const select = document.getElementById('goalTimeFilterSelect');
      if (select) select.value = state.goalTimeFilter;
    }

    function renderGoals() {
      const container = document.getElementById('goalsList');
      if (!container) return;

      // Time filter
      let allGoals = Array.isArray(state.goals) ? [...state.goals] : [];
      if (state.goalTimeFilter !== 'all') {
        const days = parseFloat(state.goalTimeFilter);
        if (!isNaN(days) && days > 0) {
          const threshold = Date.now() - (days * 24 * 60 * 60 * 1000);
          allGoals = allGoals.filter(g => getGoalLatestActivity(g) >= threshold || g.status !== 'done');
        }
      }

      const { grouped, uncategorized } = groupGoalsByCondoId();
      // Filter grouped goals by time filter
      const filteredGrouped = {};
      for (const [condoId, goals] of Object.entries(grouped)) {
        const filtered = goals.filter(g => allGoals.some(ag => ag.id === g.id));
        if (filtered.length > 0) filteredGrouped[condoId] = filtered;
      }
      const filteredUncat = uncategorized.filter(g => allGoals.some(ag => ag.id === g.id));

      // Build sorted condo list
      const condos = (state.condos || [])
        .filter(c => filteredGrouped[c.id])
        .map(c => ({ condo: c, goals: filteredGrouped[c.id] }))
        .sort((a, b) => getCondoLatestActivity(b.condo, b.goals) - getCondoLatestActivity(a.condo, a.goals));

      // Flatten all goals for counting
      const allFilteredGoals = [];
      condos.forEach(({ goals }) => allFilteredGoals.push(...goals));
      allFilteredGoals.push(...filteredUncat);

      if (!allFilteredGoals.length) {
        container.innerHTML = '<div style="padding: 12px 16px; color: var(--text-dim); font-size: 0.82rem;">No goals in this time range</div>';
        updateUncategorizedLink();
        return;
      }

      // Auto-flatten: if only 1 condo and no uncategorized, skip tree nesting
      const singleCondo = condos.length === 1 && !filteredUncat.length;

      // All user-generated content is escaped via escapeHtml() before insertion
      const html = [];

      if (singleCondo) {
        // Flat list â€” just show goals directly with a subtle condo label
        const { condo, goals } = condos[0];
        goals.sort((a, b) => getGoalLatestActivity(b) - getGoalLatestActivity(a));
        html.push(
          '<div class="condo-label">' + escapeHtml(condo.name || 'Unnamed condo') + '</div>'
        );
        html.push(renderGoalItems(goals, false));
      } else {
        // Multi-condo tree
        for (const { condo, goals } of condos) {
          goals.sort((a, b) => getGoalLatestActivity(b) - getGoalLatestActivity(a));
          const expanded = state.condoExpanded[condo.id] !== false; // default expanded
          const attention = getCondoAttention(condo, goals);
          const activeCount = goals.filter(g => {
            const s = getGoalLatestSession(g);
            return s && getAgentStatus(s.key) === 'thinking';
          }).length;

          html.push(
            '<div class="condo-group ' + (expanded ? 'expanded' : '') + '">' +
              '<div class="condo-group-header" onclick="toggleCondoExpanded(\'' + escapeHtml(condo.id) + '\')">' +
                '<span class="group-expand-icon">&#9654;</span>' +
                '<div class="goal-item-dot ' + attention + '"></div>' +
                '<span class="condo-group-name">' + escapeHtml(condo.name || 'Unnamed condo') + '</span>' +
                (activeCount > 0 ? '<span class="condo-active-badge">' + activeCount + ' active</span>' : '') +
                '<span class="group-count">' + goals.length + '</span>' +
              '</div>' +
              (expanded ? '<div class="condo-group-items">' + renderGoalItems(goals, true) + '</div>' : '') +
            '</div>'
          );
        }

        // Uncategorized goals
        if (filteredUncat.length) {
          filteredUncat.sort((a, b) => getGoalLatestActivity(b) - getGoalLatestActivity(a));
          const expanded = state.condoExpanded['__uncategorized__'] !== false;
          html.push(
            '<div class="condo-group ' + (expanded ? 'expanded' : '') + '">' +
              '<div class="condo-group-header" onclick="toggleCondoExpanded(\'__uncategorized__\')">' +
                '<span class="group-expand-icon">&#9654;</span>' +
                '<div class="goal-item-dot none"></div>' +
                '<span class="condo-group-name">Uncategorized</span>' +
                '<span class="group-count">' + filteredUncat.length + '</span>' +
              '</div>' +
              (expanded ? '<div class="condo-group-items">' + renderGoalItems(filteredUncat, true) + '</div>' : '') +
            '</div>'
          );
        }
      }

      container.innerHTML = html.join('');
      updateUncategorizedLink();
    }

    // Renders goal items for sidebar. nested=true adds indent.
    // All values escaped via escapeHtml().
    function renderGoalItems(goals, nested) {
      return goals.map(g => {
        const isActive = state.currentGoalOpenId === g.id;
        const attention = getGoalAttention(g);
        const isDone = g.status === 'done';
        const { done, total } = goalTaskStats(g);
        const activity = getGoalLatestActivity(g);
        const activityStr = activity > 0 ? timeAgo(activity) : '';
        const latestSession = getGoalLatestSession(g);
        const agentStatus = latestSession ? getAgentStatus(latestSession.key) : '';
        const isThinking = agentStatus === 'thinking';
        const sessionCount = Array.isArray(g.sessions) ? g.sessions.length : 0;
        const nextTask = (g.nextTask || '').trim();

        const classes = ['goal-item'];
        if (nested) classes.push('condo-nested');
        if (isActive) classes.push('active');
        if (isDone) classes.push('goal-done');
        if (isThinking) classes.push('goal-thinking');

        // Progress bar
        const pct = total > 0 ? Math.round((done / total) * 100) : 0;
        const progressBar = total > 0
          ? '<div class="goal-progress"><div class="goal-progress-fill' + (isThinking ? ' thinking' : '') + '" style="width:' + pct + '%;"></div></div>'
          : '';

        // Meta line: task count + time ago
        let metaParts = [];
        if (isDone) {
          metaParts.push('done');
        } else if (total > 0) {
          metaParts.push(done + '/' + total + ' tasks');
        }
        if (activityStr) metaParts.push(activityStr);
        const metaLine = metaParts.length
          ? '<div class="goal-meta-line">' + metaParts.map(p => '<span>' + escapeHtml(p) + '</span>').join('') + '</div>'
          : '';

        // Next task preview
        const nextTaskEl = nextTask
          ? '<div class="goal-next-task">Next: ' + escapeHtml(nextTask) + '</div>'
          : '';

        // Session count badge
        const countBadge = '<span class="goal-session-count">' + sessionCount + '</span>';

        return '<div class="' + classes.join(' ') + '" onclick="openGoal(\'' + escapeHtml(g.id) + '\')" title="' + escapeHtml(g.title || '') + '">' +
          '<div class="goal-item-dot ' + attention + '"></div>' +
          '<div class="goal-item-content">' +
            '<div style="display:flex;align-items:center;gap:6px;">' +
              '<div class="goal-item-title" style="flex:1;">' + escapeHtml(g.title || 'Untitled goal') + '</div>' +
              countBadge +
            '</div>' +
            progressBar +
            metaLine +
            nextTaskEl +
          '</div>' +
        '</div>';
      }).join('');
    }

    function updateUncategorizedLink() {
      const el = document.getElementById('uncategorizedLink');
      if (!el) return;
      const allSessionsInGoals = new Set();
      state.goals.forEach(g => (g.sessions || []).forEach(s => allSessionsInGoals.add(s)));
      const uncatCount = state.sessions.filter(s => !allSessionsInGoals.has(s.key) && !s.key.includes(':subagent:')).length;
      if (uncatCount > 0) {
        el.style.display = 'block';
        el.textContent = `Uncategorized (${uncatCount})`;
      } else {
        el.style.display = 'none';
      }
    }


    function goalTaskStats(goal) {
      const tasks = Array.isArray(goal?.tasks) ? goal.tasks : [];
      let done = 0;
      let total = 0;
      for (const t of tasks) {
        if (!t) continue;
        total++;
        if (t.done || t.status === 'done') done++;
      }
      return { done, total };
    }

    function getGoalForSession(sessionKey) {
      for (const g of state.goals) {
        if (Array.isArray(g.sessions) && g.sessions.includes(sessionKey)) return g;
      }
      return null;
    }

    function openGoal(goalId, opts) {
      const goal = state.goals.find(g => g.id === goalId);
      if (!goal) return;

      if (!(opts && opts.fromRouter)) {
        navigateTo('goal/' + encodeURIComponent(goalId));
        return;
      }

      // Close detail panel if open (suppress route â€” we're already navigating via router)
      closeDetailPanel({ fromRouter: true });

      // Mark latest session as read
      const latest = getGoalLatestSession(goal);
      if (latest) markSessionRead(latest.key);

      // Reset goal chat session if switching goals
      if (state.currentGoalOpenId !== goalId) {
        state.goalChatSessionKey = null;
      }

      state.currentView = 'goal';
      state.currentGoalOpenId = goalId;
      state.goalPanelOpen = false;

      document.getElementById('overviewView').classList.remove('active');
      document.getElementById('chatView').classList.remove('active');
      document.getElementById('goalView').classList.remove('panel-mode');
      document.getElementById('goalView').classList.add('active');
      document.querySelector('.main-content').classList.remove('split-view');

      document.getElementById('mainTitle').textContent = 'Goal';
      document.getElementById('mainSubtitle').textContent = '';
      document.getElementById('headerAction').style.display = 'none';
      document.getElementById('headerStatusIndicator').style.display = 'none';

      renderGoalView();
      renderGoals();
      updateMobileHeader();
      closeSidebar();
    }

    function openGoalPanel(goalId) {
      const goal = state.goals.find(g => g.id === goalId);
      if (!goal) return;

      const latest = getGoalLatestSession(goal);
      if (latest) markSessionRead(latest.key);

      if (state.currentGoalOpenId !== goalId) {
        state.goalChatSessionKey = null;
      }

      state.goalPanelOpen = true;
      state.currentGoalOpenId = goalId;

      const mainContent = document.querySelector('.main-content');
      mainContent.classList.add('split-view');
      document.getElementById('overviewView').classList.add('active');
      document.getElementById('chatView').classList.remove('active');
      document.getElementById('goalView').classList.add('active');
      document.getElementById('goalView').classList.add('panel-mode');

      renderGoalView();
      renderGoals();
    }

    function closeGoalView() {
      if (state.goalPanelOpen) {
        state.goalPanelOpen = false;
        state.currentGoalOpenId = null;
        state.goalChatSessionKey = null;
        document.querySelector('.main-content').classList.remove('split-view');
        document.getElementById('goalView').classList.remove('active');
        document.getElementById('goalView').classList.remove('panel-mode');
        renderGoals();
      } else {
        showOverview();
      }
    }

    // â”€â”€ Goal chat helpers â”€â”€

    function getLatestGoalSessionKey(goal) {
      const keys = Array.isArray(goal && goal.sessions) ? goal.sessions : [];
      if (!keys.length) return null;
      const byKey = new Map((state.sessions || []).map(function(s) { return [s.key, s]; }));
      var best = keys[0], bestT = 0;
      for (var i = 0; i < keys.length; i++) {
        var s = byKey.get(keys[i]);
        var t = Number((s && (s.updatedAt || s.updatedAtMs)) || 0);
        if (t > bestT) { bestT = t; best = keys[i]; }
      }
      return best;
    }

    function setGoalChatLocked(locked) {
      var overlay = document.getElementById('goalKickoffOverlay');
      var composer = document.getElementById('composerMountGoal');
      if (overlay) overlay.style.display = locked ? 'block' : 'none';
      if (composer) composer.style.display = locked ? 'none' : 'block';
      var btns = [document.getElementById('goalOpenBtn')].filter(Boolean);
      for (var i = 0; i < btns.length; i++) {
        btns[i].disabled = !!locked;
        btns[i].style.opacity = locked ? '0.45' : '1';
        btns[i].style.pointerEvents = locked ? 'none' : 'auto';
      }
    }

    function renderGoalHistoryPicker(goal) {
      var wrap = document.getElementById('goalHistoryWrap');
      var select = document.getElementById('goalHistorySelect');
      if (!wrap || !select) return;
      var sess = Array.isArray(goal && goal.sessions) ? goal.sessions.slice() : [];
      if (sess.length < 2) { wrap.style.display = 'none'; return; }
      var byKey = new Map((state.sessions || []).map(function(s) { return [s.key, s]; }));
      // All values escaped via escapeHtml() â€” safe against XSS
      select.innerHTML = sess.map(function(key) {
        var s = byKey.get(key);
        var label = s ? getSessionName(s) + ' \u00b7 ' + getSessionMeta(s) : key;
        return '<option value="' + escapeHtml(key) + '">' + escapeHtml(label) + '</option>';
      }).join('');
      var current = state.goalChatSessionKey && sess.includes(state.goalChatSessionKey) ? state.goalChatSessionKey : sess[0];
      if (current) select.value = current;
      wrap.style.display = 'flex';
    }

    function handleGoalHistoryChange(value) {
      if (!value || value === state.goalChatSessionKey) return;
      state.goalChatSessionKey = value;
      renderGoalChat();
      updateGoalChatMeta();
      updateGoalSessionStatePill();
    }

    function updateGoalChatMeta() {
      var el = document.getElementById('goalChatMeta');
      if (!el) return;
      var key = state.goalChatSessionKey;
      if (!key) { el.textContent = 'No session yet'; return; }
      var s = (state.sessions || []).find(function(x) { return x.key === key; });
      el.textContent = s ? getSessionName(s) + ' \u00b7 ' + getSessionMeta(s) : key;
    }

    function updateGoalSessionStatePill() {
      var dot = document.getElementById('goalSessionStateDot');
      var label = document.getElementById('goalSessionStateLabel');
      if (!dot || !label) return;
      var key = state.goalChatSessionKey;
      if (!key) {
        dot.className = 'session-state-dot blink-idle';
        label.textContent = 'Not started';
        return;
      }
      var run = state.activeRuns.get(key);
      if (run) {
        dot.className = 'session-state-dot blink-thinking';
        label.textContent = 'Thinking';
      } else {
        dot.className = 'session-state-dot blink-idle';
        label.textContent = 'Idle';
      }
    }

    async function renderGoalChat() {
      var container = document.getElementById('goal_chatMessages');
      if (!container) return;
      var sessionKey = state.goalChatSessionKey;
      if (!sessionKey) {
        container.innerHTML = '<div class="empty-state" style="padding:24px;">No session selected. Kick off or attach a session to start chatting.</div>';
        return;
      }
      container.innerHTML = '<div class="message system">Loading...</div>';
      try {
        var result = await rpcCall('chat.history', { sessionKey: sessionKey, limit: 100 });
        var messages = (result && result.messages) || [];
        if (messages.length > 0) {
          // All user-generated content is escaped via formatMessage/escapeHtml
          container.innerHTML = messages.map(function(m) {
            var text = extractText(m.content);
            if (!text) return '';
            var timeHtml = m.timestamp ? '<div class="message-time">' + formatMessageTime(new Date(m.timestamp)) + '</div>' : '';
            if (m.role === 'user') {
              return '<div class="message user"><div class="message-content">' + formatMessage(text) + '</div>' + timeHtml + '</div>';
            } else if (m.role === 'assistant') {
              return '<div class="message assistant"><div class="message-content">' + formatMessage(text) + '</div>' + timeHtml + '</div>';
            }
            return '';
          }).filter(Boolean).join('');
        } else {
          container.innerHTML = '<div class="empty-state" style="padding:24px;">No messages yet.</div>';
        }
        // Scroll the parent .goal-chat-body (the actual overflow container)
        var scrollParent = container.parentElement;
        setTimeout(function() {
          container.scrollTop = container.scrollHeight;
          if (scrollParent) scrollParent.scrollTop = scrollParent.scrollHeight;
        }, 50);
      } catch (err) {
        container.innerHTML = '<div class="message system">Error: ' + escapeHtml(err.message) + '</div>';
      }

      // Render composer
      renderGoalComposer();
    }

    function renderGoalComposer() {
      var mount = document.getElementById('composerMountGoal');
      if (!mount) return;
      var sessionKey = state.goalChatSessionKey;
      if (!sessionKey) { mount.innerHTML = ''; return; }
      // Static safe HTML â€” sessionKey escaped
      mount.innerHTML = '<div class="chat-input-area" style="border-top:1px solid var(--border-subtle);padding:10px 14px;">' +
        '<div style="display:flex;gap:8px;">' +
          '<input type="text" class="chat-input" id="goalChatInput" placeholder="Message..." style="flex:1;" onkeypress="if(event.key===\'Enter\')sendGoalMessage()">' +
          '<button class="send-btn" onclick="sendGoalMessage()" style="padding:8px 16px;">Send</button>' +
        '</div>' +
      '</div>';
    }

    async function sendGoalMessage() {
      var input = document.getElementById('goalChatInput');
      if (!input) return;
      var text = input.value.trim();
      if (!text || !state.goalChatSessionKey) return;
      input.value = '';
      try {
        await rpcCall('chat.send', { sessionKey: state.goalChatSessionKey, message: text });
        await renderGoalChat();
      } catch (err) {
        showToast('Send failed: ' + err.message, 'error');
      }
    }

    function openGoalChatInFull() {
      if (state.goalChatSessionKey) {
        openSession(state.goalChatSessionKey);
      }
    }

    async function kickOffGoal() {
      var goalId = state.currentGoalOpenId;
      var goal = state.goals.find(function(g) { return g.id === goalId; });
      if (!goal) return;
      try {
        var condoId = goal.condoId || null;
        var result = await rpcCall('sessions.create', {
          agentId: 'main',
          channelId: 'main',
          meta: { title: goal.title || 'Goal session' }
        });
        var sessionKey = result && result.sessionKey;
        if (!sessionKey) { showToast('Failed to create session', 'error'); return; }
        await rpcCall('goals.addSession', { goalId: goalId, sessionKey: sessionKey });
        if (condoId) {
          await rpcCall('goals.setSessionCondo', { sessionKey: sessionKey, condoId: condoId });
        }
        // Send goal context as first message
        var msg = 'Goal: ' + (goal.title || '') + '\n';
        if (goal.notes) msg += '\n' + goal.notes;
        var tasks = Array.isArray(goal.tasks) ? goal.tasks : [];
        if (tasks.length) {
          msg += '\n\nTasks:\n' + tasks.map(function(t) { return '- ' + (t.text || ''); }).join('\n');
        }
        await rpcCall('chat.send', { sessionKey: sessionKey, message: msg });
        state.goalChatSessionKey = sessionKey;
        await loadGoals();
        renderGoalView();
      } catch (err) {
        showToast('Kick-off failed: ' + err.message, 'error');
      }
    }

    // â”€â”€ Goal definition editing â”€â”€

    function startGoalDefEdit() {
      var display = document.getElementById('goalDefDisplay');
      var edit = document.getElementById('goalDefEdit');
      var ta = document.getElementById('goalDefTA');
      if (!display || !edit || !ta) return;
      var goal = state.goals.find(function(g) { return g.id === state.currentGoalOpenId; });
      ta.value = (goal && (goal.notes || goal.description)) || '';
      display.style.display = 'none';
      edit.style.display = 'block';
      ta.focus();
    }

    async function saveGoalDefEdit() {
      var ta = document.getElementById('goalDefTA');
      if (!ta) return;
      var goalId = state.currentGoalOpenId;
      if (!goalId) return;
      try {
        await rpcCall('goals.update', { goalId: goalId, notes: ta.value });
        await loadGoals();
        renderGoalView();
      } catch (err) {
        showToast('Save failed: ' + err.message, 'error');
      }
    }

    function cancelGoalDefEdit() {
      var display = document.getElementById('goalDefDisplay');
      var edit = document.getElementById('goalDefEdit');
      if (display) display.style.display = 'block';
      if (edit) edit.style.display = 'none';
    }

    // â”€â”€ Goal tab switching â”€â”€

    function setGoalTab(which) {
      state.goalTab = which;
      var tabTasks = document.getElementById('goalTabTasks');
      var tabFiles = document.getElementById('goalTabFiles');
      if (tabTasks) tabTasks.classList.toggle('active', which === 'tasks');
      if (tabFiles) tabFiles.classList.toggle('active', which === 'files');
      renderGoalPane();
    }

    function renderGoalPane() {
      var pane = document.getElementById('goalPane');
      if (!pane) return;
      var goal = state.goals.find(function(g) { return g.id === state.currentGoalOpenId; });
      if (!goal) { pane.innerHTML = ''; return; }

      if (state.goalTab === 'files') {
        // Tracked files â€” all values escaped via escapeHtml()
        var files = Array.isArray(goal.files) ? goal.files : [];
        if (!files.length) {
          pane.innerHTML = '<div class="empty-state">No files tracked yet.</div>';
        } else {
          pane.innerHTML = files.map(function(f) {
            var filePath = typeof f === 'string' ? f : (f.path || '');
            var ext = filePath.split('.').pop().toLowerCase();
            var source = (typeof f === 'object' && f.source) ? escapeHtml(f.source) : '';
            var addedAt = (typeof f === 'object' && f.addedAtMs) ? timeAgo(f.addedAtMs) : '';
            var meta = [source, addedAt].filter(Boolean).join(' \u00b7 ');
            return '<div class="goal-file-row">' +
              '<div class="goal-file-icon">' + getFileIcon(ext) + '</div>' +
              '<div class="goal-file-path" title="' + escapeHtml(filePath) + '">' + escapeHtml(filePath) + '</div>' +
              '<div class="goal-file-meta">' + meta + '</div>' +
              '<button class="goal-file-del" onclick="removeGoalFile(\'' + escapeHtml(goal.id) + '\',\'' + escapeHtml(filePath) + '\')" title="Remove">\u00d7</button>' +
            '</div>';
          }).join('');
        }
      } else {
        // Tasks
        var tasks = Array.isArray(goal.tasks) ? goal.tasks : [];
        if (!tasks.length) {
          pane.innerHTML = '<div class="empty-state">No tasks yet.</div>' +
            '<div class="goal-task-compose"><input class="chat-input" id="goalNewTaskInput" placeholder="Add a task\u2026" style="flex:1;" onkeypress="if(event.key===\'Enter\')addGoalTask()"><button class="ghost-btn" onclick="addGoalTask()">Add</button></div>';
        } else {
          // All values escaped via escapeHtml() â€” safe against XSS
          pane.innerHTML = tasks.map(function(t, idx) {
            var id = escapeHtml(t.id || String(idx));
            var taskStatus = t.status || (t.done ? 'done' : 'pending');
            var isDone = t.done || taskStatus === 'done';
            var hasSession = t.sessionKey ? 'has-session' : '';
            var spawnBtn = (!t.sessionKey && !isDone)
              ? '<button class="goal-task-spawn" onclick="event.stopPropagation(); openSpawnTaskModal(\'' + escapeHtml(goal.id) + '\',\'' + id + '\')" title="Spawn agent session">\u25b6</button>'
              : '';
            var tooltipParts = [taskStatus];
            if (t.sessionKey) tooltipParts.push('session: ' + t.sessionKey);
            if (t.summary) tooltipParts.push(t.summary);
            var tooltip = escapeHtml(tooltipParts.join(' \u00b7 '));
            return '<div class="goal-task ' + (isDone ? 'done' : '') + '">' +
              '<div class="goal-task-status ' + escapeHtml(taskStatus) + ' ' + hasSession + '"' +
              ' onclick="cycleTaskStatus(\'' + id + '\')"' +
              ' oncontextmenu="showTaskStatusMenu(event,\'' + id + '\')"' +
              ' title="' + tooltip + '"></div>' +
              '<span class="goal-task-text">' + escapeHtml(t.text || '') + '</span>' +
              spawnBtn +
              '<button class="goal-task-del" onclick="deleteGoalTask(\'' + id + '\')" title="Delete">\u00d7</button>' +
            '</div>';
          }).join('') +
          '<div class="goal-task-compose"><input class="chat-input" id="goalNewTaskInput" placeholder="Add a task\u2026" style="flex:1;" onkeypress="if(event.key===\'Enter\')addGoalTask()"><button class="ghost-btn" onclick="addGoalTask()">Add</button></div>';
        }
      }
    }

    function renderGoalView() {
      const goal = state.goals.find(g => g.id === state.currentGoalOpenId);
      if (!goal) return;

      const completed = (goal.status === 'done');
      const { done, total } = goalTaskStats(goal);

      // Right panel header
      document.getElementById('goalHeroTitle').textContent = goal.title || 'Untitled goal';

      var condoNameEl = document.getElementById('goalCondoName');
      if (condoNameEl) {
        var condoName = 'Condo';
        if (goal.condoId) {
          var condo = (state.condos || []).find(function(c) { return c.id === goal.condoId; });
          condoName = condo ? (condo.name || goal.condoId) : (goal.condoId.split(':').pop() || 'Condo');
        }
        condoNameEl.textContent = condoName;
      }

      var lastEl = document.getElementById('goalLastUpdated');
      if (lastEl) lastEl.textContent = timeAgo(goal.updatedAtMs || goal.updatedAt || goal.createdAtMs || Date.now());

      var btn = document.getElementById('goalMarkDoneBtn');
      if (btn) btn.textContent = completed ? 'Mark active' : 'Mark done';

      // Definition display
      var defDisplay = document.getElementById('goalDefDisplay');
      var notes = ((goal.notes || goal.description) || '').trim();
      if (defDisplay) {
        // Notes rendered via formatMessage (markdown), safe HTML
        defDisplay.innerHTML = notes
          ? '<div class="goal-def-rendered">' + formatMessage(notes) + '</div><small>(click to edit)</small>'
          : 'Click to add a definition\u2026 <small>(click to edit)</small>';
        defDisplay.style.display = 'block';
      }
      var defEdit = document.getElementById('goalDefEdit');
      if (defEdit) defEdit.style.display = 'none';

      // Goal chat: select latest session
      var sess = Array.isArray(goal.sessions) ? goal.sessions : [];
      var latestKey = getLatestGoalSessionKey(goal);
      if (!state.goalChatSessionKey || !sess.includes(state.goalChatSessionKey)) {
        state.goalChatSessionKey = latestKey;
      }
      setGoalChatLocked(!state.goalChatSessionKey);

      updateGoalChatMeta();
      renderGoalHistoryPicker(goal);
      updateGoalSessionStatePill();
      renderGoalChat();

      // Tabs + pane
      if (!state.goalTab) state.goalTab = 'tasks';
      setGoalTab(state.goalTab);
    }

    function getFileIcon(ext) {
      const map = {
        js: '\ud83d\udcdc', ts: '\ud83d\udcdc', mjs: '\ud83d\udcdc', cjs: '\ud83d\udcdc',
        json: '\ud83d\udccb', yaml: '\ud83d\udccb', yml: '\ud83d\udccb', toml: '\ud83d\udccb',
        md: '\ud83d\uddd2\ufe0f', txt: '\ud83d\uddd2\ufe0f',
        css: '\ud83c\udfa8', scss: '\ud83c\udfa8', less: '\ud83c\udfa8',
        html: '\ud83c\udf10', htm: '\ud83c\udf10',
        py: '\ud83d\udc0d', rb: '\ud83d\udc8e', go: '\ud83d\udce6', rs: '\u2699\ufe0f',
        sh: '\u26a1', bash: '\u26a1',
        png: '\ud83d\uddbc\ufe0f', jpg: '\ud83d\uddbc\ufe0f', svg: '\ud83d\uddbc\ufe0f', gif: '\ud83d\uddbc\ufe0f',
        sql: '\ud83d\uddc4\ufe0f', db: '\ud83d\uddc4\ufe0f',
      };
      return map[ext] || '\ud83d\udcc4';
    }

    async function removeGoalFile(goalId, path) {
      try {
        await rpcCall('goals.removeFile', { goalId, path });
        await loadGoals();
        renderGoalView();
      } catch (e) {
        showToast('Failed to remove file', 'error');
      }
    }

    async function toggleGoalDone() {
      const goal = state.goals.find(g => g.id === state.currentGoalOpenId);
      if (!goal) return;
      const next = goal.status === 'done' ? 'active' : 'done';
      await updateGoal(goal.id, { status: next });
    }

    async function updateGoal(goalId, patch) {
      try {
        const data = await rpcCall('goals.update', { id: goalId, ...patch });
        const idx = state.goals.findIndex(g => g.id === goalId);
        if (idx !== -1 && data?.goal) state.goals[idx] = data.goal;
        renderGoals();
        renderCondoStatusBoard();
        renderGoalView();
      } catch (e) {
        showToast('Failed to save goal', 'error');
      }
    }

    function uid(prefix='id') {
      return `${prefix}_${Math.random().toString(16).slice(2)}${Date.now().toString(16)}`;
    }

    async function addGoalTask() {
      const goal = state.goals.find(g => g.id === state.currentGoalOpenId);
      if (!goal) return;
      const input = document.getElementById('goalNewTaskInput');
      const text = (input.value || '').trim();
      if (!text) return;
      const tasks = Array.isArray(goal.tasks) ? goal.tasks.slice() : [];
      tasks.unshift({ id: uid('task'), text, done: false, status: 'pending' });
      input.value = '';
      await updateGoal(goal.id, { tasks });
    }

    async function cycleTaskStatus(taskId) {
      const goal = state.goals.find(g => g.id === state.currentGoalOpenId);
      if (!goal) return;
      const tasks = Array.isArray(goal.tasks) ? goal.tasks.map(t => ({...t})) : [];
      const idx = tasks.findIndex(t => String(t.id) === String(taskId));
      if (idx === -1) return;
      const cur = tasks[idx].status || (tasks[idx].done ? 'done' : 'pending');
      const cycle = { pending: 'in-progress', 'in-progress': 'done', done: 'pending', blocked: 'in-progress', waiting: 'in-progress' };
      const next = cycle[cur] || 'pending';
      tasks[idx].status = next;
      tasks[idx].done = next === 'done';
      await updateGoal(goal.id, { tasks });
    }

    function showTaskStatusMenu(event, taskId) {
      event.preventDefault();
      const existing = document.querySelector('.task-status-menu');
      if (existing) existing.remove();

      const menu = document.createElement('div');
      menu.className = 'task-status-menu';
      menu.style.left = event.clientX + 'px';
      menu.style.top = event.clientY + 'px';

      const statuses = ['pending', 'in-progress', 'waiting', 'blocked', 'done'];
      for (const s of statuses) {
        const item = document.createElement('div');
        item.className = 'task-status-menu-item';
        // All text set via textContent â€” safe against XSS
        const dot = document.createElement('span');
        dot.className = 'dot ' + s;
        const label = document.createElement('span');
        label.textContent = s;
        item.appendChild(dot);
        item.appendChild(label);
        item.onclick = () => { menu.remove(); setTaskStatus(taskId, s); };
        menu.appendChild(item);
      }

      document.body.appendChild(menu);
      const close = (e) => { if (!menu.contains(e.target)) { menu.remove(); document.removeEventListener('click', close); } };
      setTimeout(() => document.addEventListener('click', close), 0);
    }

    async function setTaskStatus(taskId, status) {
      const goal = state.goals.find(g => g.id === state.currentGoalOpenId);
      if (!goal) return;
      const tasks = Array.isArray(goal.tasks) ? goal.tasks.map(t => ({...t})) : [];
      const idx = tasks.findIndex(t => String(t.id) === String(taskId));
      if (idx === -1) return;
      tasks[idx].status = status;
      tasks[idx].done = status === 'done';
      await updateGoal(goal.id, { tasks });
    }

    async function deleteGoalTask(taskId) {
      const goal = state.goals.find(g => g.id === state.currentGoalOpenId);
      if (!goal) return;
      const tasks = Array.isArray(goal.tasks) ? goal.tasks.filter(t => String(t.id) != String(taskId)) : [];
      await updateGoal(goal.id, { tasks });
    }

    // Spawn task session modal
    state.spawnGoalId = null;
    state.spawnTaskId = null;

    async function openSpawnTaskModal(goalId, taskId) {
      const goal = state.goals.find(g => g.id === goalId);
      const task = goal?.tasks?.find(t => t.id === taskId);
      if (!task) return;

      state.spawnGoalId = goalId;
      state.spawnTaskId = taskId;

      document.getElementById('spawnTaskDesc').textContent = 'Spawn session for: ' + (task.text || 'Untitled task');
      document.getElementById('spawnTaskError').style.display = 'none';

      // Populate agent select
      const agentSelect = document.getElementById('spawnAgentSelect');
      agentSelect.textContent = '';
      let agents = [];
      try {
        const res = await rpcCall('agents.list', {});
        agents = res?.agents || [];
      } catch (e) { /* fallback */ }
      if (!agents.length) agents = [{ id: 'main' }];
      for (const a of agents) {
        const opt = document.createElement('option');
        opt.value = a.id;
        opt.textContent = a.identity?.name || a.id;
        agentSelect.appendChild(opt);
      }

      const btn = document.getElementById('spawnTaskBtn');
      btn.disabled = false;
      btn.textContent = 'Spawn Session';

      document.getElementById('spawnTaskModal').classList.remove('hidden');
    }

    function hideSpawnTaskModal() {
      document.getElementById('spawnTaskModal').classList.add('hidden');
    }

    async function confirmSpawnTask() {
      const errEl = document.getElementById('spawnTaskError');
      errEl.style.display = 'none';
      const btn = document.getElementById('spawnTaskBtn');
      btn.disabled = true;
      btn.textContent = 'Spawningâ€¦';

      const agentId = document.getElementById('spawnAgentSelect').value;
      const model = document.getElementById('spawnModelSelect').value;

      try {
        const res = await rpcCall('goals.spawnTaskSession', {
          goalId: state.spawnGoalId,
          taskId: state.spawnTaskId,
          agentId,
          model,
        });
        const sessionKey = res?.sessionKey;
        if (sessionKey) {
          const taskContext = res.taskContext;
          await rpcCall('chat.send', {
            sessionKey,
            message: taskContext + '\n\nPlease begin working on this task.',
          });
          hideSpawnTaskModal();
          await loadGoals();
          await loadSessions();
          showToast('Session spawned', 'success');
        } else {
          throw new Error('No session key returned');
        }
      } catch (err) {
        errEl.textContent = 'Failed to spawn session: ' + (err.message || err);
        errEl.style.display = 'block';
        btn.disabled = false;
        btn.textContent = 'Spawn Session';
      }
    }

    const GOAL_TOOL_NAMES = new Set(['goal_update', 'condo_bind', 'condo_create_goal', 'condo_add_task', 'condo_spawn_task']);
    let goalRefreshTimer = null;
    function debouncedGoalRefresh() {
      clearTimeout(goalRefreshTimer);
      goalRefreshTimer = setTimeout(async () => {
        await Promise.all([loadCondos(), loadGoals()]);
        renderGoalView();
      }, 500);
    }

    let goalSaveTimer = null;
    function debouncedSaveGoal() {
      clearTimeout(goalSaveTimer);
      goalSaveTimer = setTimeout(saveGoalNow, 450);
      const hint = document.getElementById('goalSaveHint');
      if (hint) {
        hint.textContent = 'Savingâ€¦';
        hint.classList.add('saving');
      }
    }

    async function saveGoalNow() {
      // Notes are now saved through saveGoalDefEdit()
    }

    async function promptDeleteGoal() {
      const goal = state.goals.find(g => g.id === state.currentGoalOpenId);
      if (!goal) return;
      if (!confirm(`Delete goal "${goal.title}"? This does not delete sessions.`)) return;
      try {
        await rpcCall('goals.delete', { id: goal.id });
        await loadGoals();
        showOverview();
      } catch {
        showToast('Failed to delete goal', 'error');
      }
    }

    // Attach session modal
    function showAttachSessionModal(sessionKey) {
      const modal = document.getElementById('attachSessionModal');
      const errEl = document.getElementById('attachSessionError');
      errEl.style.display = 'none';
      modal.classList.remove('hidden');

      const key = sessionKey || state.currentSession?.key || null;
      state.attachSessionKey = key;
      document.getElementById('attachSessionPill').textContent = key ? key : 'No session selected';

      if (!state.attachGoalId && state.currentGoalOpenId) state.attachGoalId = state.currentGoalOpenId;
      if (!state.attachGoalId && state.goals[0]) state.attachGoalId = state.goals[0].id;

      const picker = document.getElementById('goalPicker');
      const rows = state.goals.map(g => {
        const active = state.attachGoalId === g.id ? 'active' : '';
        const { done, total } = goalTaskStats(g);
        const due = g.deadline ? `<span class="goal-picker-due">due ${escapeHtml(g.deadline)}</span>` : '';
        return `
          <div class="goal-picker-row ${active}" onclick="selectAttachGoal('${escapeHtml(g.id)}')">
            <div class="goal-picker-title">${escapeHtml(g.title || 'Untitled goal')}</div>
            <div class="goal-picker-meta">${g.status === 'done' ? 'done' : 'active'} Â· ${done}/${total} tasks ${due}</div>
          </div>
        `;
      }).join('');
      picker.innerHTML = rows || `<div class="empty-state">No goals yet. Create one first.</div>`;
    }

    function selectAttachGoal(goalId) {
      state.attachGoalId = goalId;
      // re-render picker active state
      showAttachSessionModal(state.attachSessionKey);
    }

    function hideAttachSessionModal() {
      document.getElementById('attachSessionModal').classList.add('hidden');
    }

    async function confirmAttachSession() {
      const errEl = document.getElementById('attachSessionError');
      errEl.style.display = 'none';
      const goalId = state.attachGoalId;
      const sessionKey = state.attachSessionKey;
      if (!goalId) {
        errEl.textContent = 'Pick a goal';
        errEl.style.display = 'block';
        return;
      }
      if (!sessionKey) {
        errEl.textContent = 'No session selected';
        errEl.style.display = 'block';
        return;
      }
      try {
        await rpcCall('goals.addSession', { id: goalId, sessionKey });
        hideAttachSessionModal();
        await loadGoals();
        renderSessions();
        updateOverview();
        if (state.currentView === 'goal') renderGoalView();
        showToast('Session attached', 'success');
      } catch {
        errEl.textContent = 'Failed to attach session';
        errEl.style.display = 'block';
      }
    }

    // Per-session goal suggestion state
    state.suggestingSessionKey = null;
    state.pendingSuggestions = [];

    function showCategorizeSuggestions(sessionKey, event) {
      if (event) event.stopPropagation();
      
      state.suggestingSessionKey = sessionKey;
      state.pendingSuggestions = [];
      
      // Find session info
      const session = state.sessions.find(s => s.key === sessionKey);
      const sessionName = session ? (session.displayName || session.label || sessionKey.split(':').pop()) : sessionKey;
      
      // Update modal
      document.getElementById('suggestSessionPill').textContent = sessionName;
      document.getElementById('suggestGoalDesc').textContent = 'Analyzing session to suggest goals...';
      document.getElementById('suggestGoalLoading').style.display = 'block';
      document.getElementById('suggestGoalResults').style.display = 'none';
      document.getElementById('suggestNewGoalSection').style.display = 'none';
      document.getElementById('suggestGoalError').style.display = 'none';
      document.getElementById('suggestGoalModal').classList.remove('hidden');
      
      // Trigger AI analysis
      analyzeSesssionForGoals(sessionKey, sessionName);
    }
    
    function hideSuggestGoalModal() {
      document.getElementById('suggestGoalModal').classList.add('hidden');
      state.suggestingSessionKey = null;
      state.pendingSuggestions = [];
    }
    
    async function analyzeSesssionForGoals(sessionKey, sessionName) {
      try {
        const goals = state.goals || [];
        
        // Fetch session history - get first 5 (topic) and last 5 (recent) messages
        let firstMessages = '';
        let lastMessages = '';
        try {
          const historyResult = await rpcCall('chat.history', { sessionKey, limit: 50 });
          if (historyResult?.messages) {
            const userMsgs = historyResult.messages.filter(m => m.role === 'user');
            
            // First 5 user messages (understand the original topic)
            const first5 = userMsgs.slice(0, 5);
            firstMessages = first5.map(m => {
              const text = typeof m.content === 'string' ? m.content : 
                (Array.isArray(m.content) ? m.content.filter(c => c.type === 'text').map(c => c.text).join(' ') : '');
              return text.slice(0, 150);
            }).join(' | ');
            
            // Last 5 user messages (recent context)
            const last5 = userMsgs.slice(-5);
            lastMessages = last5.map(m => {
              const text = typeof m.content === 'string' ? m.content : 
                (Array.isArray(m.content) ? m.content.filter(c => c.type === 'text').map(c => c.text).join(' ') : '');
              return text.slice(0, 150);
            }).join(' | ');
          }
        } catch (e) {
          console.log('Could not fetch history:', e);
        }
        
        // Build context string for AI analysis
        const contextForAI = `Session: ${sessionKey}
Name: ${sessionName}
First messages (original topic): ${firstMessages.slice(0, 400) || '(none)'}
Recent messages: ${lastMessages.slice(0, 400) || '(none)'}`;
        
        // If we have goals, ask AI to rank them
        if (goals.length > 0) {
          const goalsList = goals.map(g => `- "${g.title}" (id: ${g.id})`).join('\n');
          
          const message = `[CATEGORIZE-SESSION]
Analyze this session and suggest which goal it belongs to. Respond with ONLY a JSON object, no other text.

${contextForAI}

Available goals:
${goalsList}

Response format:
{"suggestions":[{"goalId":"id-here","title":"Goal Title","reason":"brief reason","confidence":"high|medium|low"}]}

If none fit well, include a suggestion with goalId:null and a proposed new goal title.`;

          // Send to AI and wait for response
          document.getElementById('suggestGoalDesc').textContent = 'AI is analyzing the session...';
          
          try {
            // Send request and listen for response
            const reqId = await sendCategorizationRequest(sessionKey, message);
            // Response will come via WebSocket event - set up listener
            state.pendingCategorizationReqId = reqId;
            state.pendingCategorizationSessionKey = sessionKey;
            
            // Timeout fallback to manual
            setTimeout(() => {
              if (state.suggestingSessionKey === sessionKey) {
                showManualGoalOptions();
              }
            }, 8000);
            
          } catch (e) {
            console.error('AI request failed:', e);
            showManualGoalOptions();
          }
        } else {
          // No goals yet - just show create option
          showManualGoalOptions();
        }
        
      } catch (e) {
        console.error('Analyze session error:', e);
        showManualGoalOptions();
      }
    }
    
    async function sendCategorizationRequest(sessionKey, message) {
      if (!state.ws || !state.connected) throw new Error('Not connected');
      
      const reqId = String(++state.rpcIdCounter);
      
      state.ws.send(JSON.stringify({
        type: 'req',
        id: reqId,
        method: 'chat.send',
        params: {
          sessionKey: 'agent:main:main',
          message: message,
        }
      }));
      
      return reqId;
    }
    
    // Handle categorization response from AI
    function handleCategorizationResponse(text) {
      if (!state.suggestingSessionKey) return;
      
      try {
        // Try to parse JSON from the response
        const jsonMatch = text.match(/\{[\s\S]*"suggestions"[\s\S]*\}/);
        if (jsonMatch) {
          const data = JSON.parse(jsonMatch[0]);
          if (data.suggestions && Array.isArray(data.suggestions)) {
            showAISuggestions(data.suggestions);
            return;
          }
        }
      } catch (e) {
        console.log('Could not parse AI response:', e);
      }
      
      // Fallback to manual
      showManualGoalOptions();
    }
    
    function showAISuggestions(suggestions) {
      const goals = state.goals || [];
      const container = document.getElementById('goalSuggestions');
      
      document.getElementById('suggestGoalLoading').style.display = 'none';
      document.getElementById('suggestGoalResults').style.display = 'block';
      document.getElementById('suggestNewGoalSection').style.display = 'block';
      document.getElementById('suggestGoalDesc').textContent = 'AI suggestions (click to assign):';
      
      const html = suggestions.map(s => {
        const isNew = !s.goalId;
        const confidence = s.confidence || 'medium';
        const confidenceClass = confidence === 'high' ? 'high' : (confidence === 'low' ? 'low' : 'medium');
        
        if (isNew) {
          return `
            <div class="goal-suggestion-row new-goal" onclick="createAndAssignGoal('${escapeHtml(s.title || 'New Goal')}')">
              <div class="suggestion-icon">âœ¨</div>
              <div class="suggestion-content">
                <div class="suggestion-title">Create: ${escapeHtml(s.title || 'New Goal')}</div>
                <div class="suggestion-reason">${escapeHtml(s.reason || 'Suggested new goal')}</div>
              </div>
              <div class="suggestion-confidence">${confidence}</div>
            </div>
          `;
        } else {
          const goal = goals.find(g => g.id === s.goalId);
          const title = goal?.title || s.title || 'Unknown';
          return `
            <div class="goal-suggestion-row" onclick="assignSessionToGoal('${escapeHtml(s.goalId)}')">
              <div class="suggestion-icon">ğŸ™ï¸</div>
              <div class="suggestion-content">
                <div class="suggestion-title">${escapeHtml(title)}</div>
                <div class="suggestion-reason">${escapeHtml(s.reason || '')}</div>
              </div>
              <div class="suggestion-confidence">${confidence}</div>
            </div>
          `;
        }
      }).join('');
      
      container.innerHTML = html || '<div class="empty-state">No suggestions. Pick manually below.</div>';
    }
    
    async function createAndAssignGoal(title) {
      const sessionKey = state.suggestingSessionKey;
      if (!sessionKey || !title) return;

      try {
        const data = await rpcCall('goals.create', { title });

        if (data?.goal?.id) {
          await rpcCall('goals.addSession', { id: data.goal.id, sessionKey });
        }

        hideSuggestGoalModal();
        await loadGoals();
        renderSessions();

      } catch (e) {
        document.getElementById('suggestGoalError').textContent = 'Failed: ' + e.message;
        document.getElementById('suggestGoalError').style.display = 'block';
      }
    }
    
    function showManualGoalOptions() {
      const goals = state.goals || [];
      document.getElementById('suggestGoalLoading').style.display = 'none';
      document.getElementById('suggestGoalResults').style.display = 'block';
      document.getElementById('suggestNewGoalSection').style.display = 'block';
      document.getElementById('suggestGoalDesc').textContent = 'Pick a goal or create a new one:';
      
      // Render existing goals as options
      const container = document.getElementById('goalSuggestions');
      if (goals.length === 0) {
        container.innerHTML = '<div class="empty-state">No goals yet. Create one below.</div>';
      } else {
        container.innerHTML = goals.map(g => `
          <div class="goal-suggestion-row" onclick="assignSessionToGoal('${escapeHtml(g.id)}')">
            <div class="suggestion-icon">ğŸ™ï¸</div>
            <div class="suggestion-content">
              <div class="suggestion-title">${escapeHtml(g.title)}</div>
              <div class="suggestion-reason">${g.sessions?.length || 0} sessions Â· ${g.status || 'active'}</div>
            </div>
          </div>
        `).join('');
      }
    }
    
    async function assignSessionToGoal(goalId) {
      const sessionKey = state.suggestingSessionKey;
      if (!sessionKey) return;

      try {
        await rpcCall('goals.addSession', { id: goalId, sessionKey });

        hideSuggestGoalModal();
        await loadGoals();
        renderSessions();

      } catch (e) {
        document.getElementById('suggestGoalError').textContent = 'Failed to assign: ' + e.message;
        document.getElementById('suggestGoalError').style.display = 'block';
      }
    }
    
    async function createGoalFromSuggestion() {
      const title = document.getElementById('suggestNewGoalTitle').value.trim();
      if (!title) {
        document.getElementById('suggestGoalError').textContent = 'Enter a goal title';
        document.getElementById('suggestGoalError').style.display = 'block';
        return;
      }

      const sessionKey = state.suggestingSessionKey;

      try {
        const data = await rpcCall('goals.create', { title });

        if (sessionKey && data?.goal?.id) {
          await rpcCall('goals.addSession', { id: data.goal.id, sessionKey });
        }

        hideSuggestGoalModal();
        await loadGoals();
        renderSessions();

      } catch (e) {
        document.getElementById('suggestGoalError').textContent = 'Failed: ' + e.message;
        document.getElementById('suggestGoalError').style.display = 'block';
      }
    }
    
    // Keep autoCategorize for bulk operations (optional)
    async function autoCategorize() {
      const sessions = (state.sessions || []).filter(s => !s.key.includes(':subagent:'));
      const goals = state.goals || [];
      
      // Find uncategorized sessions
      const assignedSessions = new Set();
      goals.forEach(g => (g.sessions || []).forEach(s => assignedSessions.add(s)));
      const uncategorized = sessions.filter(s => !assignedSessions.has(s.key));
      
      if (uncategorized.length === 0) {
        showToast('All sessions are already categorized!', 'info');
        return;
      }
      
      showToast(`${uncategorized.length} sessions need categorization. Use the ğŸ·ï¸ button on each session.`, 'warning', 7000);
    }
    
    async function sendChatMessage(text) {
      if (!state.ws || !state.connected) throw new Error('Not connected');
      
      const reqId = String(++state.rpcIdCounter);
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          state.rpcPending.delete(reqId);
          reject(new Error('Request timeout'));
        }, 30000);
        
        state.rpcPending.set(reqId, {
          resolve: (result) => {
            clearTimeout(timeout);
            resolve(result);
          },
          reject: (err) => {
            clearTimeout(timeout);
            reject(err);
          }
        });
        
        state.ws.send(JSON.stringify({
          type: 'req',
          id: reqId,
          method: 'chat.send',
          params: {
            sessionKey: 'agent:main:main',
            message: text,
            idempotencyKey: crypto.randomUUID(),
          }
        }));
      });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ORGANIZE WIZARD (Sequential triage)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    state.wizardSessions = [];
    state.wizardIndex = 0;
    state.wizardOrganized = 0;
    state.wizardSkipped = 0;
    state.wizardCurrentProposal = null;
    
    function openOrganizeWizard() {
      const sessions = (state.sessions || []).filter(s => !s.key.includes(':subagent:'));
      const goals = state.goals || [];
      
      // Find uncategorized sessions
      const assignedSessions = new Set();
      goals.forEach(g => (g.sessions || []).forEach(s => assignedSessions.add(s)));
      const uncategorized = sessions.filter(s => !assignedSessions.has(s.key));
      
      if (uncategorized.length === 0) {
        showToast('All sessions are already categorized! ğŸ‰', 'success');
        return;
      }
      
      // Initialize wizard state
      state.wizardSessions = uncategorized;
      state.wizardIndex = 0;
      state.wizardOrganized = 0;
      state.wizardSkipped = 0;
      state.wizardCurrentProposal = null;
      
      // Show modal
      document.getElementById('organizeWizardModal').classList.remove('hidden');
      document.getElementById('wizardGoalPicker').classList.add('hidden');
      
      // Load first session
      loadWizardSession();
    }
    
    function closeOrganizeWizard() {
      document.getElementById('organizeWizardModal').classList.add('hidden');
      // Refresh data
      loadGoals();
      renderSessions();
    }
    
    async function loadWizardSession() {
      const sessions = state.wizardSessions;
      const idx = state.wizardIndex;
      
      if (idx >= sessions.length) {
        // Done!
        document.getElementById('wizardContent').innerHTML = `
          <div style="text-align: center; padding: 40px;">
            <div style="font-size: 3rem; margin-bottom: 16px;">ğŸ‰</div>
            <h3>All done!</h3>
            <p style="color: var(--text-dim);">
              Organized: ${state.wizardOrganized} sessions<br>
              Skipped: ${state.wizardSkipped} sessions
            </p>
          </div>
        `;
        document.getElementById('wizardAcceptBtn')?.remove();
        return;
      }
      
      const session = sessions[idx];
      const sessionName = session.displayName || session.label || session.key.split(':').pop();
      
      // Update progress
      document.getElementById('wizardProgress').textContent = `${idx + 1} of ${sessions.length}`;
      document.getElementById('wizardProgressBar').style.width = `${((idx + 1) / sessions.length) * 100}%`;
      document.getElementById('wizardStats').textContent = `${state.wizardOrganized} done Â· ${state.wizardSkipped} skipped`;
      
      // Update session info
      document.getElementById('wizardSessionIcon').textContent = getSessionIcon(session);
      document.getElementById('wizardSessionTitle').textContent = sessionName;
      document.getElementById('wizardSessionKey').textContent = session.key;
      
      // Update content preview
      const summaryEl = document.getElementById('wizardSummary');
      if (summaryEl) {
        summaryEl.innerHTML = 'Loading messages...';
      }
      
      // Update goal suggestion
      const proposalEl = document.getElementById('wizardProposedGoal');
      if (proposalEl) {
        proposalEl.innerHTML = `
          <div class="wiz-goal-name">Analyzing...</div>
          <div class="wiz-goal-reason">Finding the best goal for this session</div>
        `;
      }
      
      document.getElementById('wizardGoalPicker').classList.add('hidden');
      
      // Fetch history and generate summary + proposal
      await analyzeForWizard(session);
    }
    
    async function analyzeForWizard(session) {
      const goals = state.goals || [];
      const sessionKey = session.key;
      const sessionName = session.displayName || session.label || session.key.split(':').pop();
      
      // Fetch history
      let firstMessages = '';
      let lastMessages = '';
      try {
        const historyResult = await rpcCall('chat.history', { sessionKey, limit: 50 });
        if (historyResult?.messages) {
          const userMsgs = historyResult.messages.filter(m => m.role === 'user');
          
          const first5 = userMsgs.slice(0, 5);
          firstMessages = first5.map(m => {
            const text = typeof m.content === 'string' ? m.content : 
              (Array.isArray(m.content) ? m.content.filter(c => c.type === 'text').map(c => c.text).join(' ') : '');
            return text.slice(0, 150);
          }).join(' | ');
          
          const last5 = userMsgs.slice(-5);
          lastMessages = last5.map(m => {
            const text = typeof m.content === 'string' ? m.content : 
              (Array.isArray(m.content) ? m.content.filter(c => c.type === 'text').map(c => c.text).join(' ') : '');
            return text.slice(0, 150);
          }).join(' | ');
        }
      } catch (e) {
        console.log('Could not fetch history:', e);
      }
      
      // Show summary - format nicely
      const summaryText = firstMessages || lastMessages || 'No messages found';
      const formattedSummary = summaryText
        .split(' | ')
        .filter(s => s.trim())
        .map(s => `â€¢ ${escapeHtml(s.slice(0, 100))}${s.length > 100 ? '...' : ''}`)
        .slice(0, 5)
        .join('<br>');
      document.getElementById('wizardSummary').innerHTML = formattedSummary || 'No messages found';
      
      // Request AI proposal
      if (goals.length > 0) {
        const goalsList = goals.map(g => `- "${g.title}" (id: ${g.id})`).join('\n');
        
        const message = `[WIZARD-CATEGORIZE]
Analyze this session and suggest the BEST goal. Respond with ONLY JSON, no other text.

Session: ${sessionKey}
Name: ${sessionName}
First messages: ${firstMessages.slice(0, 300)}
Recent messages: ${lastMessages.slice(0, 300)}

Available goals:
${goalsList}

IMPORTANT: 
- Goals should be HIGH-LEVEL projects/initiatives (e.g. "Dashboard Development", "Investor Outreach", "Infrastructure Setup") - NOT granular tasks
- If no existing goal fits well, suggest a NEW high-level goal
- Group related work under broader themes

Response format:
If existing goal fits: {"goalId":"the-id","title":"Goal Title","reason":"why","isNew":false}
If new goal needed: {"goalId":null,"title":"High-Level Project Name","reason":"why new","isNew":true}`;

        try {
          if (!state.ws || !state.connected) {
            throw new Error('WebSocket not connected');
          }
          state.wizardPendingSessionKey = sessionKey;
          console.log('[Wizard] Sending AI request with', goals.length, 'existing goals...');
          await sendChatMessage(message);
          console.log('[Wizard] Request sent, waiting for response...');
          
          // Wait for response (timeout to manual)
          setTimeout(() => {
            if (state.wizardPendingSessionKey === sessionKey && !state.wizardCurrentProposal) {
              console.log('[Wizard] Timeout - showing manual picker');
              showWizardManualProposal();
            }
          }, 10000);
          
        } catch (e) {
          console.error('[Wizard] Error:', e);
          showWizardManualProposal();
        }
      } else {
        // No goals - ask AI to suggest a name for a new goal
        const message = `[WIZARD-CATEGORIZE]
Analyze this session and suggest a NEW high-level goal. Respond with ONLY JSON, no other text.

Session: ${sessionKey}
Name: ${sessionName}
First messages: ${firstMessages.slice(0, 300)}
Recent messages: ${lastMessages.slice(0, 300)}

No existing goals - suggest a HIGH-LEVEL project/initiative name (e.g. "Dashboard Development", "Investor Outreach", "Infrastructure Setup").
NOT a granular task - think broader themes that could contain multiple sessions.

Response format:
{"goalId":null,"title":"High-Level Project Name","reason":"what this project covers","isNew":true}`;

        try {
          if (!state.ws || !state.connected) {
            throw new Error('WebSocket not connected');
          }
          state.wizardPendingSessionKey = sessionKey;
          console.log('[Wizard] Sending AI request for goal suggestion...');
          await sendChatMessage(message);
          console.log('[Wizard] Request sent, waiting for response...');
          
          setTimeout(() => {
            if (state.wizardPendingSessionKey === sessionKey && !state.wizardCurrentProposal) {
              console.log('[Wizard] Timeout - no response received');
              state.wizardCurrentProposal = { goalId: null, title: 'New Goal', reason: 'AI timeout - suggest manually', isNew: true };
              showWizardProposal(state.wizardCurrentProposal);
            }
          }, 10000);
        } catch (e) {
          console.error('[Wizard] Error:', e);
          state.wizardCurrentProposal = { goalId: null, title: 'New Goal', reason: e.message || 'Error analyzing', isNew: true };
          showWizardProposal(state.wizardCurrentProposal);
        }
      }
    }
    
    function handleWizardResponse(text) {
      if (!state.wizardPendingSessionKey) return false;
      
      try {
        const jsonMatch = text.match(/\{[\s\S]*"goalId"[\s\S]*\}/);
        if (jsonMatch) {
          const data = JSON.parse(jsonMatch[0]);
          state.wizardCurrentProposal = data;
          showWizardProposal(data);
          state.wizardPendingSessionKey = null;
          return true;
        }
      } catch (e) {
        console.log('Could not parse wizard response:', e);
      }
      
      return false;
    }
    
    function showWizardProposal(proposal) {
      const goals = state.goals || [];
      const goal = proposal.goalId ? goals.find(g => g.id === proposal.goalId) : null;
      const title = goal?.title || proposal.title || 'New Goal';
      const reason = proposal.reason || '';
      const isNew = !proposal.goalId || proposal.isNew;
      
      document.getElementById('wizardProposedGoal').innerHTML = `
        <div class="wiz-goal-name">${isNew ? 'âœ¨ ' : 'ğŸ“ '}${escapeHtml(title)}</div>
        <div class="wiz-goal-reason">${escapeHtml(reason)}</div>
      `;
      
      const acceptBtn = document.getElementById('wizardAcceptBtn');
      acceptBtn.textContent = isNew ? 'âœ“ Create Goal' : 'âœ“ Accept';
      acceptBtn.style.display = '';
    }
    
    function showWizardManualProposal() {
      state.wizardCurrentProposal = null;
      document.getElementById('wizardProposedGoal').innerHTML = `
        <div class="wiz-goal-name" style="color: var(--text-dim);">No clear match</div>
        <div class="wiz-goal-reason">Choose a goal below or create new</div>
      `;
      document.getElementById('wizardAcceptBtn').style.display = 'none';
      showWizardGoalPicker();
    }
    
    function showWizardGoalPicker() {
      const goals = state.goals || [];
      const container = document.getElementById('wizardGoalList');
      
      if (goals.length === 0) {
        container.innerHTML = '<div class="empty-state">No goals yet</div>';
      } else {
        container.innerHTML = goals.map(g => `
          <div class="goal-picker-row" onclick="assignWizardGoal('${escapeHtml(g.id)}')">
            <div class="goal-picker-title">ğŸ™ï¸ ${escapeHtml(g.title)}</div>
            <div class="goal-picker-meta">${g.sessions?.length || 0} sessions</div>
          </div>
        `).join('');
      }
      
      document.getElementById('wizardGoalPicker').classList.remove('hidden');
    }
    
    async function acceptWizardProposal() {
      const proposal = state.wizardCurrentProposal;
      if (!proposal) {
        showWizardGoalPicker();
        return;
      }
      
      const sessionKey = state.wizardSessions[state.wizardIndex]?.key;
      if (!sessionKey) return;
      
      try {
        if (proposal.goalId && !proposal.isNew) {
          await rpcCall('goals.addSession', { id: proposal.goalId, sessionKey });
        } else {
          const data = await rpcCall('goals.create', { title: proposal.title || 'New Goal' });
          if (data?.goal?.id) {
            await rpcCall('goals.addSession', { id: data.goal.id, sessionKey });
            await loadGoals();
          }
        }
        
        state.wizardOrganized++;
        nextWizardSession();
        
      } catch (e) {
        console.error('Failed to assign:', e);
        showToast('Failed to assign: ' + e.message, 'error');
      }
    }
    
    async function assignWizardGoal(goalId) {
      const sessionKey = state.wizardSessions[state.wizardIndex]?.key;
      if (!sessionKey) return;

      try {
        await rpcCall('goals.addSession', { id: goalId, sessionKey });

        state.wizardOrganized++;
        nextWizardSession();

      } catch (e) {
        showToast('Failed to assign: ' + e.message, 'error');
      }
    }
    
    async function createGoalInWizard() {
      const title = document.getElementById('wizardNewGoalTitle').value.trim();
      if (!title) return;

      const sessionKey = state.wizardSessions[state.wizardIndex]?.key;
      if (!sessionKey) return;

      try {
        const data = await rpcCall('goals.create', { title });

        if (data?.goal?.id) {
          await rpcCall('goals.addSession', { id: data.goal.id, sessionKey });
          await loadGoals();
        }

        document.getElementById('wizardNewGoalTitle').value = '';
        state.wizardOrganized++;
        nextWizardSession();

      } catch (e) {
        showToast('Failed: ' + e.message, 'error');
      }
    }
    
    function skipWizardSession() {
      state.wizardSkipped++;
      nextWizardSession();
    }
    
    function nextWizardSession() {
      state.wizardIndex++;
      state.wizardCurrentProposal = null;
      state.wizardPendingSessionKey = null;
      loadWizardSession();
    }

    function showCreateGoalModal() {
      document.getElementById('createGoalModal').classList.remove('hidden');
      document.getElementById('createGoalTitle').value = '';
      document.getElementById('createGoalDeadline').value = '';
      document.getElementById('createGoalError').style.display = 'none';
      setTimeout(() => document.getElementById('createGoalTitle')?.focus(), 0);
    }

    function hideCreateGoalModal() {
      document.getElementById('createGoalModal').classList.add('hidden');
    }

    async function createGoal() {
      const title = document.getElementById('createGoalTitle').value.trim();
      const deadline = document.getElementById('createGoalDeadline').value.trim();
      const errEl = document.getElementById('createGoalError');
      if (!title) {
        errEl.textContent = 'Title is required';
        errEl.style.display = 'block';
        return;
      }
      try {
        const data = await rpcCall('goals.create', { title, deadline: deadline || undefined });
        hideCreateGoalModal();
        await loadGoals();
        if (data?.goal?.id) openGoal(data.goal.id);
      } catch (e) {
        errEl.textContent = 'Failed to create goal';
        errEl.style.display = 'block';
      }
    }

    async function refresh() {
      if (!state.connected) return;
      
      // Clean up stale runs periodically (in case we missed 'done' events)
      cleanStaleRuns();
      
      await Promise.all([loadCondos(), loadSessions(), loadGoals()]);
      updateOverview();
      renderGoalView();
    }
    
    function cleanStaleRuns() {
      const now = Date.now();
      let changed = false;
      
      for (const [key, data] of Object.entries(state.activeRunsStore)) {
        const age = now - (data.startedAt || 0);
        if (age > ACTIVE_RUN_STALE_MS) {
          console.log(`[ClawCondos] Cleaning stale run for ${key} (${Math.round(age/1000)}s old)`);
          state.activeRuns.delete(key);
          delete state.activeRunsStore[key];
          // Reset status to idle if it was thinking
          if (state.sessionAgentStatus[key] === 'thinking') {
            state.sessionAgentStatus[key] = 'idle';
          }
          changed = true;
        }
      }
      
      if (changed) {
        saveActiveRuns();
        renderSessions();
        renderSessionsGrid();
      }
    }
    
    async function loadSessions() {
      try {
        console.log('[ClawCondos] Loading sessions...');
        const result = await rpcCall('sessions.list', { limit: 50 });
        console.log('[ClawCondos] Sessions result:', result);
        if (result?.sessions) {
          state.sessions = result.sessions;
          // Goals chips depend on total session count
          renderGoals();
          // Initialize/update status for sessions
          for (const s of state.sessions) {
            // Active runs take priority (restored from localStorage or from WebSocket events)
            if (state.activeRuns.has(s.key)) {
              state.sessionAgentStatus[s.key] = 'thinking';
            } else if (!state.sessionAgentStatus[s.key]) {
              // Default to idle for new sessions
              state.sessionAgentStatus[s.key] = 'idle';
            }
          }
          renderSessions();
          renderSessionsGrid();
          updateUncategorizedCount();
          // Agents tree uses sessions for its nested view
          if (state.agents?.length) renderAgents();
        }
      } catch (err) {
        console.error('[ClawCondos] Failed to load sessions:', err);
      }
    }
    
    async function loadApps() {
      try {
        const res = await fetch('api/apps');
        if (!res.ok) return;
        const text = await res.text();
        if (!text) return;
        const data = JSON.parse(text);
        state.apps = data.apps || [];
        renderApps();
        state.apps.forEach(checkAppStatus);
      } catch (err) {
        console.error('Failed to load apps:', err);
      }
    }
    
    async function loadAgents() {
      try {
        const result = await rpcCall('agents.list', {});
        if (result?.agents) {
          state.agents = result.agents;
          renderAgents();
        }
      } catch (err) {
        console.error('Failed to load agents:', err);
      }
    }
    
    function renderAgents() {
      const container = document.getElementById('agentsList');

      if (state.agents.length === 0) {
        container.innerHTML = `<div style="padding: 16px; color: var(--text-dim); font-size: 0.85rem;">No agents configured</div>`;
        return;
      }

      // Build a lightweight tree: Agent -> Sessions -> Subsessions.
      // NOTE: The backend session model does not currently expose parent pointers for subagents,
      // so we group by agentId only.
      const sessionsByAgent = new Map();
      for (const a of state.agents) {
        sessionsByAgent.set(a.id, { sessions: [], subsessions: [] });
      }

      for (const s of (state.sessions || [])) {
        const m = s.key.match(/^agent:([^:]+):/);
        if (!m) continue;
        const agentId = m[1];
        if (!sessionsByAgent.has(agentId)) continue;
        if (s.key.includes(':subagent:')) sessionsByAgent.get(agentId).subsessions.push(s);
        else sessionsByAgent.get(agentId).sessions.push(s);
      }

      // Sort newest first
      for (const group of sessionsByAgent.values()) {
        group.sessions.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
        group.subsessions.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
      }

      container.innerHTML = state.agents.map(agent => {
        const emoji = agent.identity?.emoji || 'ğŸ¤–';
        const name = agent.identity?.name || agent.name || agent.id;
        const isDefault = agent.isDefault ? ' (default)' : '';
        const expanded = isAgentExpanded(agent.id);
        const group = sessionsByAgent.get(agent.id) || { sessions: [], subsessions: [] };

        const sessionsHtml = group.sessions.length
          ? group.sessions.map(s => renderSessionItem(s, true)).join('')
          : `<div style="padding: 10px 16px 10px 48px; color: var(--text-dim); font-size: 0.8rem;">No sessions</div>`;

        const subsessionsHtml = group.subsessions.length
          ? group.subsessions.map(s => renderSessionItem(s, true)).join('')
          : `<div style="padding: 10px 16px 10px 48px; color: var(--text-dim); font-size: 0.8rem;">No subsessions</div>`;

        return `
          <div class="session-group ${expanded ? 'expanded' : ''}">
            <div class="session-group-header" onclick="toggleAgentExpanded('${escapeHtml(agent.id)}')">
              <span class="group-expand-icon">${expanded ? 'â–¼' : 'â–¶'}</span>
              <span class="group-icon">${escapeHtml(emoji)}</span>
              <span class="group-name">${escapeHtml(name)}${isDefault}</span>
              <span class="group-count">${group.sessions.length + group.subsessions.length}</span>
              <button class="session-action-btn" onclick="event.stopPropagation(); startNewSession('${escapeHtml(agent.id)}')" title="New session">ï¼‹</button>
              <button class="session-action-btn" onclick="event.stopPropagation(); showAgentDetails('${escapeHtml(agent.id)}')" title="Details">â„¹</button>
            </div>
            ${expanded ? `
              <div class="session-group-items">
                <div class="session-group-header" style="padding-left: 36px; font-size: 0.78rem; color: var(--text-dim); cursor: default;">
                  <span class="group-expand-icon" style="visibility: hidden;">â–¶</span>
                  <span class="group-icon">ğŸ’¬</span>
                  <span class="group-name">Sessions</span>
                  <span class="group-count">${group.sessions.length}</span>
                </div>
                ${sessionsHtml}
                <div class="session-group-header" style="padding-left: 36px; font-size: 0.78rem; color: var(--text-dim); cursor: default; border-top: 1px solid var(--border-subtle);">
                  <span class="group-expand-icon" style="visibility: hidden;">â–¶</span>
                  <span class="group-icon">âš¡</span>
                  <span class="group-name">Subsessions</span>
                  <span class="group-count">${group.subsessions.length}</span>
                </div>
                ${subsessionsHtml}
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }
    
    function showAgentDetails(agentId) {
      const agent = state.agents.find(a => a.id === agentId);
      if (!agent) return;
      
      const emoji = agent.identity?.emoji || 'ğŸ¤–';
      const name = agent.identity?.name || agent.name || agent.id;
      
      state.currentView = 'agent';
      document.getElementById('mainTitle').textContent = `${emoji} ${name}`;
      document.getElementById('mainSubtitle').textContent = `Agent: ${agent.id}`;
      
      const contentArea = document.getElementById('overviewArea');
      contentArea.innerHTML = `
        <div class="agent-details" style="padding: 24px;">
          <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 24px;">
            <div style="font-size: 3rem;">${escapeHtml(emoji)}</div>
            <div>
              <h2 style="margin: 0;">${escapeHtml(name)}</h2>
              <div style="color: var(--text-dim);">ID: ${escapeHtml(agent.id)}</div>
              ${agent.isDefault ? '<div style="color: var(--green); font-size: 0.85rem;">Default Agent</div>' : ''}
            </div>
          </div>
          
          <div style="display: grid; gap: 16px; max-width: 600px;">
            <div class="detail-card" style="background: var(--bg-secondary); padding: 16px; border-radius: 8px;">
              <div style="font-weight: 600; margin-bottom: 8px;">Model</div>
              <div style="color: var(--text-dim);">${escapeHtml(agent.model || 'Default')}</div>
            </div>
            
            <div class="detail-card" style="background: var(--bg-secondary); padding: 16px; border-radius: 8px;">
              <div style="font-weight: 600; margin-bottom: 8px;">Workspace</div>
              <div style="color: var(--text-dim);">${escapeHtml(agent.workspace || 'Default')}</div>
            </div>
          </div>
          
          <button onclick="startNewSession('${escapeHtml(agent.id)}')" 
                  style="margin-top: 24px; padding: 12px 24px; background: var(--accent); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem;">
            Start New Session
          </button>
        </div>
      `;
      
      document.getElementById('overviewArea').style.display = 'block';
      document.getElementById('chatArea').style.display = 'none';
      updateMobileHeader();
      closeSidebar();
    }
    
    async function startNewSession(agentId) {
      const timestamp = Date.now();
      const sessionKey = `agent:${agentId}:webchat:${timestamp}`;
      const idempotencyKey = `new-${agentId}-${timestamp}`;
      try {
        // Initialize session by sending a greeting
        await rpcCall('chat.send', {
          sessionKey,
          message: 'Hello!',
          idempotencyKey
        });
        // Open the new session
        openSession(sessionKey);
      } catch (err) {
        console.error('Failed to start session:', err);
        showToast('Failed to start new session: ' + err.message, 'error');
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSIONS UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    

    function renderSessionGoalBadge(sessionKey) {
      const g = getGoalForSession(sessionKey);
      if (!g) return '';
      const due = g.deadline ? ` Â· due ${escapeHtml(g.deadline)}` : '';
      return `<div class="session-goal-badge" onclick="event.stopPropagation(); openGoal('${escapeHtml(g.id)}')" title="Open goal">ğŸ™ï¸ ${escapeHtml(g.title || 'Goal')}${due}</div>`;
    }

    function renderSessionItem(s, isNested = false) {
      const isActive = state.currentSession && state.currentSession.key === s.key;
      const isSelected = state.selectedSessions.has(s.key);
      const agentStatus = getAgentStatus(s.key);
      const tooltip = getStatusTooltip(agentStatus);
      const isPinned = isSessionPinned(s.key);
      const clickHandler = state.multiSelectMode 
        ? `toggleSessionSelection('${escapeHtml(s.key)}')`
        : `openSession('${escapeHtml(s.key)}')`;
      
      const isGenerating = state.generatingTitles.has(s.key);
      const sessionName = getSessionName(s, true);  // This triggers auto-generation
      const hasUnread = !isActive && isSessionUnread(s.key);
      const parsed = parseSessionGroup(s.key);
      
      // For nested items, use full session name (with auto-generated title if available)
      let displayName = sessionName;
      
      return `
        <div class="item ${isActive ? 'active' : ''} ${hasUnread ? 'unread' : ''} ${isNested ? 'nested-item' : ''}" data-session-key="${escapeHtml(s.key)}" onclick="${clickHandler}">
          <div class="session-checkbox ${isSelected ? 'checked' : ''}" data-key="${escapeHtml(s.key)}" onclick="toggleSessionSelection('${escapeHtml(s.key)}', event)"></div>
          <div class="item-icon">${isNested ? 'ğŸ’¬' : getSessionIcon(s)}${s.compactionCount > 0 ? '<span class="compaction-badge" title="Compacted ' + s.compactionCount + 'x">ğŸ“œ</span>' : ''}</div>
          <div class="item-content">
            <div class="item-name ${isGenerating ? 'title-generating' : ''}">${escapeHtml(displayName)}</div>
            <div class="item-meta">${escapeHtml(getSessionMeta(s))}</div>
            ${renderSessionGoalBadge(s.key)}
            ${renderSessionStatusLine(s.key)}
          </div>
          <div class="session-actions">
            <button class="session-action-btn ${hasUnread ? 'unread' : ''}" 
                    onclick="${hasUnread ? `markSessionRead('${escapeHtml(s.key)}'); event.stopPropagation(); renderSessions();` : `markSessionUnread('${escapeHtml(s.key)}', event)`}" 
                    title="${hasUnread ? 'Mark read' : 'Mark unread'}">
              ${hasUnread ? 'â—' : 'â—‹'}
            </button>
            <button class="session-action-btn ${isPinned ? 'pinned' : ''}" 
                    onclick="event.stopPropagation(); togglePinSession('${escapeHtml(s.key)}')" 
                    title="${isPinned ? 'Unpin' : 'Pin'}">
              ${isPinned ? 'â˜…' : 'â˜†'}
            </button>
            <button class="session-action-btn" 
                    onclick="promptRenameSession('${escapeHtml(s.key)}', event)" 
                    title="Rename">
              âœï¸
            </button>
            <button class="session-action-btn" 
                    onclick="generateSessionTitle('${escapeHtml(s.key)}', event)" 
                    title="Auto-generate title">
              âœ¨
            </button>
            <button class="session-action-btn" 
                    onclick="askSessionForSummary('${escapeHtml(s.key)}', event)" 
                    title="Ask for full summary">
              ğŸ“‹
            </button>
            ${!s.key.includes(':subagent:') ? `<button class="session-action-btn categorize-btn" 
                    onclick="showCategorizeSuggestions('${escapeHtml(s.key)}', event)" 
                    title="Suggest goal for this session">
              ğŸ·ï¸
            </button>` : ''}
          </div>
          <div class="agent-status ${agentStatus}" data-tooltip="${tooltip}"></div>
        </div>
      `;
    }
    
    function buildSubagentParentMap(mainSessions, subagentSessions) {
      // Heuristic parenting: we don't have explicit parent pointers.
      // We attach each subagent to the closest-in-time main session for the same agent.
      const byAgent = new Map();
      for (const s of mainSessions) {
        const m = s.key.match(/^agent:([^:]+):/);
        const agentId = m ? m[1] : null;
        if (!agentId) continue;
        if (!byAgent.has(agentId)) byAgent.set(agentId, []);
        byAgent.get(agentId).push(s);
      }
      for (const arr of byAgent.values()) {
        arr.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
      }

      const parentMap = new Map(); // parentSessionKey -> subagent[]
      const unparented = [];

      const MAX_ATTACH_AGE_MS = 2 * 60 * 60 * 1000; // 2h window
      const ALLOW_FUTURE_PARENT_MS = 5 * 60 * 1000; // tolerate slight clock/order skew

      for (const sub of subagentSessions) {
        const m = sub.key.match(/^agent:([^:]+):/);
        const agentId = m ? m[1] : null;
        const candidates = agentId ? (byAgent.get(agentId) || []) : [];

        let best = null;
        let bestScore = Infinity;
        const subTime = sub.updatedAt || 0;

        for (const cand of candidates) {
          const candTime = cand.updatedAt || 0;
          const dt = Math.abs(subTime - candTime);

          // Avoid attaching to something wildly unrelated
          if (dt > MAX_ATTACH_AGE_MS) continue;

          // Prefer candidates not too far "after" the subagent (but allow a bit)
          if (candTime - subTime > ALLOW_FUTURE_PARENT_MS) continue;

          if (dt < bestScore) {
            best = cand;
            bestScore = dt;
          }
        }

        if (best) {
          if (!parentMap.has(best.key)) parentMap.set(best.key, []);
          parentMap.get(best.key).push(sub);
        } else {
          unparented.push(sub);
        }
      }

      // Sort each child list newest-first
      for (const arr of parentMap.values()) {
        arr.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
      }
      unparented.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));

      return { parentMap, unparented };
    }

    function renderSessions() {
      const container = document.getElementById('sessionsList');
      if (!container) return;

      // Show/hide mark all read button
      const markAllReadBtn = document.getElementById('markAllReadBtn');
      if (markAllReadBtn) {
        const unreadCount = getUnreadCount();
        markAllReadBtn.style.display = unreadCount > 0 ? 'inline-flex' : 'none';
        markAllReadBtn.title = `Mark all read (${unreadCount})`;
      }

      // Build set of ALL sessions that are in ANY goal (for hiding from main Sessions list)
      const allSessionsInGoals = new Set();
      state.goals.forEach(g => (g.sessions || []).forEach(s => allSessionsInGoals.add(s)));

      let displaySessions = state.sessions.filter(s => {
        // Hide sessions that are in any goal â€” goals are the primary nav now
        if (allSessionsInGoals.has(s.key)) return false;
        if (!matchesSearch(s)) return false;
        return true;
      });

      // Split out subagents - they render inline in parent chat, not in sidebar
      const subagentSessions = displaySessions.filter(s => s.key.includes(':subagent:'));
      const mainDisplaySessions = displaySessions.filter(s => !s.key.includes(':subagent:'));

      const { parentMap: subagentsByParent, unparented: unparentedSubagents } = buildSubagentParentMap(
        mainDisplaySessions,
        subagentSessions
      );

      // Sort: pinned first, then by updatedAt
      mainDisplaySessions.sort((a, b) => {
        const aPinned = isSessionPinned(a.key);
        const bPinned = isSessionPinned(b.key);
        if (aPinned && !bPinned) return -1;
        if (!aPinned && bPinned) return 1;
        return (b.updatedAt || 0) - (a.updatedAt || 0);
      });
      
      if (displaySessions.length === 0) {
        container.innerHTML = `<div style="padding: 16px; color: var(--text-dim); font-size: 0.85rem;">No uncategorized sessions</div>`;
        return;
      }
      
      // Group sessions by their parent group
      const groups = new Map(); // groupKey -> { sessions: [], latestUpdate: number }
      const standalone = []; // sessions that don't belong to a group
      
      for (const s of mainDisplaySessions) {
        const parsed = parseSessionGroup(s.key);
        if (parsed.type === 'topic' && parsed.isGrouped) {
          if (!groups.has(parsed.groupKey)) {
            groups.set(parsed.groupKey, { sessions: [], latestUpdate: 0 });
          }
          const group = groups.get(parsed.groupKey);
          group.sessions.push(s);
          group.latestUpdate = Math.max(group.latestUpdate, s.updatedAt || 0);
        } else {
          standalone.push(s);
        }
      }
      
      // Sort sessions within each group by updatedAt
      for (const group of groups.values()) {
        group.sessions.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
      }
      
      // Build combined list: groups + standalone, sorted by latest activity
      const combined = [];
      for (const [groupKey, group] of groups) {
        combined.push({ type: 'group', groupKey, ...group });
      }
      for (const s of standalone) {
        combined.push({ type: 'session', session: s, latestUpdate: s.updatedAt || 0 });
      }
      
      // Sort combined by pinned status and latest update
      combined.sort((a, b) => {
        // Check if any session in group is pinned
        const aPinned = a.type === 'group' 
          ? a.sessions.some(s => isSessionPinned(s.key))
          : isSessionPinned(a.session.key);
        const bPinned = b.type === 'group'
          ? b.sessions.some(s => isSessionPinned(s.key))
          : isSessionPinned(b.session.key);
        if (aPinned && !bPinned) return -1;
        if (!aPinned && bPinned) return 1;
        return (b.latestUpdate || 0) - (a.latestUpdate || 0);
      });
      
      // Render
      let html = '';
      for (const item of combined) {
        if (item.type === 'group') {
          const expanded = isGroupExpanded(item.groupKey);
          const groupName = getGroupDisplayName(item.groupKey);
          const unreadCount = item.sessions.filter(s => isSessionUnread(s.key)).length;
          const hasActiveSession = item.sessions.some(s => state.currentSession?.key === s.key);
          
          html += `
            <div class="session-group ${hasActiveSession ? 'has-active' : ''}">
              <div class="session-group-header" onclick="toggleGroupExpanded('${escapeHtml(item.groupKey)}')">
                <span class="group-expand-icon">${expanded ? 'â–¼' : 'â–¶'}</span>
                <span class="group-icon">ğŸ‘¥</span>
                <span class="group-name">${escapeHtml(groupName)}</span>
                <span class="group-count">${item.sessions.length}</span>
                ${unreadCount > 0 ? `<span class="group-unread">${unreadCount}</span>` : ''}
                <button class="session-action-btn" onclick="event.stopPropagation(); generateGroupTitles('${escapeHtml(item.groupKey)}', event)" title="Auto-generate all topic titles">âœ¨</button>
                <button class="session-action-btn" onclick="event.stopPropagation(); promptRenameSession('${escapeHtml(item.groupKey)}', event)" title="Rename group">âœï¸</button>
              </div>
              ${expanded ? `<div class="session-group-items">${item.sessions.map(s => renderSessionItem(s, true)).join('')}</div>` : ''}
            </div>
          `;
        } else {
          const s = item.session;
          // Subagents render inline in parent chat, not in sidebar
          html += renderSessionItem(s, false);
        }
      }
      
      // Subagents are no longer shown in sidebar - they appear inline in parent session chat

      container.innerHTML = html;
      
      // Update select all checkbox state
      if (state.multiSelectMode) {
        updateCheckboxStates();
      }
    }
    
    function getSessionIcon(s) {
      if (s.key.includes(':subagent:')) return 'âš¡';
      if (s.key.includes(':app:')) return 'ğŸ› ï¸';
      if (s.key.startsWith('cron:')) return 'â°';
      if (s.key.includes(':group:')) return 'ğŸ‘¥';
      return 'ğŸ’¬';
    }
    
    function getSessionName(s, triggerAutoGen = false) {
      // Check for custom name first
      const customName = getCustomSessionName(s.key);
      if (customName) return customName;
      
      // Check if currently generating
      if (state.generatingTitles.has(s.key)) {
        return 'âœ¨ Generating';
      }
      
      // Auto-trigger title generation for sessions with messages
      if (triggerAutoGen && !state.attemptedTitles.has(s.key)) {
        // Only auto-generate for sessions that have messages and aren't special
        const isSpecial = s.key === 'agent:main:main' || 
                         s.key.includes(':subagent:') || 
                         s.key.includes(':app:') ||
                         s.key.startsWith('cron:');
        if (!isSpecial && s.totalTokens > 0) {
          autoGenerateTitle(s.key);
        }
      }
      
      return getDefaultSessionName(s);
    }
    
    function getDefaultSessionName(s) {
      if (!s) return 'Unknown';
      if (s.key === 'agent:main:main') return 'Main';
      if (s.key.includes(':subagent:')) return s.label || 'Sub-agent';
      if (s.key.includes(':app:')) return `App: ${s.key.split(':app:')[1]}`;
      if (s.key.startsWith('cron:')) return s.key.replace('cron:', 'Cron: ');
      // Telegram topics: show "Topic N" or channel info
      if (s.key.includes(':topic:')) {
        const topicMatch = s.key.match(/:topic:(\d+)$/);
        if (topicMatch) return `Topic ${topicMatch[1]}`;
      }
      // Telegram groups without topic
      if (s.key.includes(':telegram:group:')) {
        const groupMatch = s.key.match(/:group:(-?\d+)(?:$|:)/);
        if (groupMatch) return `Group ${groupMatch[1].slice(-4)}`;
      }
      // Telegram DMs
      if (s.key.includes(':telegram:') && !s.key.includes(':group:')) {
        return s.displayName || 'Telegram DM';
      }
      return s.displayName || s.key.split(':').pop();
    }
    
    function getSessionMeta(s) {
      const ago = timeAgo(s.updatedAt);
      const model = s.model ? s.model.split('/').pop().split('-')[0] : '';
      return `${ago}${model ? ' â€¢ ' + model : ''}`;
    }
    
    function isSessionCompacted(s) {
      return s.compactionCount > 0;
    }
    
    function getSessionStatus(s) {
      // Check if actively streaming
      if (state.activeRuns.has(s.key)) return 'running';
      if (s.abortedLastRun) return 'error';
      const mins = (Date.now() - s.updatedAt) / 60000;
      if (mins < 2) return 'active';
      return 'idle';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // APPS UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function renderApps() {
      const container = document.getElementById('appsList');
      
      if (state.apps.length === 0) {
        container.innerHTML = `<div style="padding: 16px; color: var(--text-dim); font-size: 0.85rem;">No apps configured</div>`;
        return;
      }
      
      container.innerHTML = state.apps.map(app => `
        <a href="/app?id=${escapeHtml(app.id)}" target="_blank" class="item">
          <div class="item-icon">${escapeHtml(app.icon || 'ğŸ“¦')}</div>
          <div class="item-content">
            <div class="item-name">${escapeHtml(app.name)}</div>
            <div class="item-meta">:${app.port}</div>
          </div>
          <div class="item-status idle" id="app-status-${escapeHtml(app.id)}" title="Checking..."></div>
        </a>
      `).join('');
    }
    
    async function checkAppStatus(app) {
      const dot = document.getElementById(`app-status-${app.id}`);
      if (!dot) return;
      
      try {
        const res = await fetch(`/${app.id}/`, { method: 'HEAD' });
        const ok = res.ok || res.status === 401;
        dot.className = 'item-status ' + (ok ? 'active' : 'error');
        dot.title = ok ? 'App is running' : 'App is not responding';
      } catch {
        dot.className = 'item-status error';
        dot.title = 'App is not responding';
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MOBILE NAVIGATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('sidebarOverlay');
      sidebar.classList.toggle('open');
      overlay.classList.toggle('active');
      document.body.style.overflow = sidebar.classList.contains('open') ? 'hidden' : '';
    }
    
    function closeSidebar() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('sidebarOverlay');
      sidebar.classList.remove('open');
      overlay.classList.remove('active');
      document.body.style.overflow = '';
    }
    
    function updateMobileHeader() {
      const menuBtn = document.getElementById('menuBtn');
      const backBtn = document.getElementById('backBtn');
      const mobileTitle = document.getElementById('mobileTitle');
      
      if (state.currentView === 'chat' && state.currentSession) {
        menuBtn.style.display = 'none';
        backBtn.style.display = 'flex';
        mobileTitle.textContent = getSessionName(state.currentSession);
      } else if (state.currentView === 'agent') {
        menuBtn.style.display = 'none';
        backBtn.style.display = 'flex';
        mobileTitle.textContent = document.getElementById('mainTitle').textContent;
      } else if (state.currentView === 'goal') {
        menuBtn.style.display = 'none';
        backBtn.style.display = 'flex';
        const g = state.goals.find(x => x.id === state.currentGoalOpenId);
        mobileTitle.textContent = g ? g.title : 'Goal';
      } else {
        menuBtn.style.display = 'flex';
        backBtn.style.display = 'none';
        mobileTitle.textContent = 'ClawCondos';
      }
    }
    
    function goBack() {
      if (window.history.length > 1) {
        history.back();
      } else {
        showOverview();
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VIEWS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showOverview(opts) {
      if (!(opts && opts.fromRouter)) {
        navigateTo('dashboard');
        return;
      }

      state.currentView = 'overview';
      state.currentSession = null;
      state.goalPanelOpen = false;
      state.currentGoalOpenId = null;
      state.goalChatSessionKey = null;
      localStorage.removeItem('sharp_current_session');

      // Close detail panel if open (suppress route push since we're already routing)
      closeDetailPanel({ fromRouter: true });

      document.getElementById('overviewView').classList.add('active');
      document.getElementById('chatView').classList.remove('active');
      document.getElementById('goalView').classList.remove('active');
      document.getElementById('goalView').classList.remove('panel-mode');
      document.querySelector('.main-content').classList.remove('split-view');
      document.getElementById('mainTitle').textContent = 'Dashboard';
      document.getElementById('mainSubtitle').textContent = '';
      document.getElementById('headerAction').style.display = 'none';
      document.getElementById('headerStatusIndicator').style.display = 'none';

      renderSessions();
      renderGoals();
      updateMobileHeader();
      closeSidebar();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION DETAIL PANEL (inline third column)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function openDetailPanel(sessionKey, opts) {
      const session = state.sessions.find(s => s.key === sessionKey);
      if (!session) return;

      if (!(opts && opts.fromRouter)) {
        navigateTo('detail/' + encodeURIComponent(sessionKey));
        return;
      }

      state.detailPanelSessionKey = sessionKey;
      markSessionRead(sessionKey);

      document.getElementById('detailPanelTitle').textContent = getSessionName(session);
      document.querySelector('.main-content').classList.add('detail-open');

      const chatContainer = document.getElementById('detailChatMessages');
      // Static safe HTML â€” no user content
      chatContainer.innerHTML = '<div class="message system">Loading...</div>';

      try {
        const result = await rpcCall('chat.history', { sessionKey: sessionKey, limit: 50 });
        const messages = result?.messages || [];
        if (messages.length > 0) {
          renderDetailChatHistory(chatContainer, messages);
        } else {
          // Static safe HTML â€” no user content
          chatContainer.innerHTML = '<div class="message system">No messages yet</div>';
        }
        // Scroll to bottom â€” try both container and parent for reliability
        setTimeout(function() {
          chatContainer.scrollTop = chatContainer.scrollHeight;
          if (chatContainer.parentElement) chatContainer.parentElement.scrollTop = chatContainer.parentElement.scrollHeight;
        }, 50);
      } catch (err) {
        chatContainer.innerHTML = '<div class="message system">Error: ' + escapeHtml(err.message) + '</div>';
      }

      // Add composer for sending messages
      renderDetailComposer(sessionKey);
    }

    function closeDetailPanel(opts) {
      if (!state.detailPanelSessionKey) return;
      state.detailPanelSessionKey = null;
      document.querySelector('.main-content').classList.remove('detail-open');
      document.getElementById('detailChatMessages').innerHTML = '';
      document.getElementById('detailComposerMount').innerHTML = '';
      // Navigate back to dashboard (unless called from router)
      if (!(opts && opts.fromRouter)) {
        navigateTo('dashboard', true);
      }
    }

    function renderDetailChatHistory(container, messages) {
      // All user-generated content is escaped via escapeHtml() before insertion
      container.innerHTML = messages.map(function(m, idx) {
        var text = extractText(m.content);
        if (!text) return '';
        var timeHtml = m.timestamp ? '<div class="message-time">' + formatMessageTime(new Date(m.timestamp)) + '</div>' : '';
        if (m.role === 'user') {
          return '<div class="message user"><div class="message-content">' + formatMessage(text) + '</div>' + timeHtml + '</div>';
        } else if (m.role === 'assistant') {
          return '<div class="message assistant"><div class="message-content">' + formatMessage(text) + '</div>' + timeHtml + '</div>';
        }
        return '';
      }).filter(Boolean).join('');
    }

    function renderDetailComposer(sessionKey) {
      var mount = document.getElementById('detailComposerMount');
      // All values are escaped or static
      mount.innerHTML = '<div class="chat-input-area" style="border-top:1px solid var(--border-subtle);padding:var(--space-md) var(--space-lg);">' +
        '<div style="display:flex;gap:8px;">' +
          '<input type="text" class="chat-input" id="detailChatInput" placeholder="Message..." style="flex:1;" onkeypress="if(event.key===\'Enter\')sendDetailMessage(\'' + escapeHtml(sessionKey) + '\')">' +
          '<button class="send-btn" onclick="sendDetailMessage(\'' + escapeHtml(sessionKey) + '\')" style="padding:8px 16px;">Send</button>' +
        '</div>' +
        '<div style="display:flex;gap:8px;margin-top:6px;">' +
          '<button class="ghost-btn" onclick="openSession(\'' + escapeHtml(sessionKey) + '\')" style="font-size:11px;color:var(--text-dim);background:none;border:none;cursor:pointer;padding:2px 0;">Open full view</button>' +
        '</div>' +
      '</div>';
    }

    async function sendDetailMessage(sessionKey) {
      var input = document.getElementById('detailChatInput');
      if (!input) return;
      var text = input.value.trim();
      if (!text) return;
      input.value = '';

      try {
        await rpcCall('chat.send', { sessionKey: sessionKey, message: text });
        // Reload panel chat (suppress route push â€” just a refresh)
        await openDetailPanel(sessionKey, { fromRouter: true });
      } catch (err) {
        console.error('[ClawCondos] Detail send error:', err);
      }
    }

    async function openSession(key, opts) {
      const session = state.sessions.find(s => s.key === key);
      if (!session) return;

      if (!(opts && opts.fromRouter)) {
        navigateTo('session/' + encodeURIComponent(key));
        return;
      }

      // Close detail panel if open (suppress route â€” already navigating via router)
      closeDetailPanel({ fromRouter: true });

      // Save to localStorage for restore on refresh
      localStorage.setItem('sharp_current_session', key);

      // Mark session as read
      markSessionRead(key);

      // Clear tool activity from previous session
      clearAllTools();
      
      state.currentView = 'chat';
      state.currentSession = session;
      state.chatHistory = [];
      state.isThinking = state.activeRuns.has(key);
      
      // Initialize session status if not set
      if (!state.sessionAgentStatus[key]) {
        state.sessionAgentStatus[key] = state.connected ? 'idle' : 'offline';
        localStorage.setItem('sharp_session_agent_status', JSON.stringify(state.sessionAgentStatus));
      }
      
      document.getElementById('overviewView').classList.remove('active');
      document.getElementById('chatView').classList.add('active');
      document.getElementById('mainTitle').textContent = getSessionName(session);
      document.getElementById('mainSubtitle').textContent = session.key;
      
      // Show header status indicator
      document.getElementById('headerStatusIndicator').style.display = 'block';
      updateHeaderStatus();
      
      document.getElementById('sessionKeyDisplay').textContent = session.key;
      renderSessionModelSelector(session);
      document.getElementById('sessionTokens').textContent = session.totalTokens?.toLocaleString() || '0';
      updateVerboseToggleUI();
      
      const actionBtn = document.getElementById('headerAction');
      if (session.key === 'agent:main:main') {
        actionBtn.textContent = '+ New Session';
        actionBtn.style.display = 'block';
      } else {
        actionBtn.style.display = 'none';
      }
      
      renderSessions();
      updateSendButton();
      updateMobileHeader();
      closeSidebar();
      
      await loadSessionHistory(key);
      
      document.getElementById('chatInput').focus();
    }
    
    async function loadSessionHistory(key) {
      const container = document.getElementById('chatMessages');
      container.innerHTML = '<div class="message system">Loading history...</div>';
      
      try {
        const result = await rpcCall('chat.history', { sessionKey: key, limit: 50 });
        const messages = result?.messages || [];
        
        if (messages.length > 0) {
          renderChatHistory(messages);
        } else {
          container.innerHTML = '<div class="message system">No messages yet</div>';
        }
      } catch (err) {
        container.innerHTML = `<div class="message system">Error loading history: ${escapeHtml(err.message)}</div>`;
      }
    }
    
    function renderChatHistory(messages) {
      const container = document.getElementById('chatMessages');
      
      if (!messages || messages.length === 0) {
        container.innerHTML = '<div class="message system">No messages yet. Start the conversation!</div>';
        return;
      }
      
      container.innerHTML = messages.map((m, idx) => {
        if (m.role === 'user') {
          const text = extractText(m.content);
          if (!text) return '';
          const timeHtml = m.timestamp ? `<div class="message-time">${formatMessageTime(new Date(m.timestamp))}</div>` : '';
          const msgIdAttr = m.id ? ` data-message-id="${escapeHtml(String(m.id))}"` : '';
          return `<div class="message user" data-message-idx="${idx}"${msgIdAttr}><div class="message-content">${formatMessage(text)}</div>${timeHtml}</div>`;
        } else if (m.role === 'assistant') {
          const text = extractText(m.content);
          const spawnCards = extractSpawnCards(m.content, m.timestamp);
          const timeHtml = m.timestamp ? `<div class="message-time">${formatMessageTime(new Date(m.timestamp))}</div>` : '';
          
          // Render spawn cards inline with the message
          let html = '';
          if (spawnCards.length > 0) {
            html += spawnCards.map(card => renderSpawnCard(card, idx)).join('');
          }
          if (text) {
            const shaped = shapeForDisplay(text);
            if (!shaped.suppressed) {
              const replyChip = renderReplyChip(shaped.replyTo, idx - 1);
              const msgIdAttr = m.id ? ` data-message-id="${escapeHtml(String(m.id))}"` : '';
              html += `<div class="message assistant" data-message-idx="${idx}"${msgIdAttr}>${replyChip}<div class="message-content">${formatMessage(shaped.text)}</div>${timeHtml}</div>`;
            }
          }
          return html;
        }
        return '';
      }).filter(Boolean).join('');
      
      scrollChatToBottom();
    }
    
    // Extract sessions_spawn tool calls from message content
    function extractSpawnCards(content, timestamp) {
      if (!Array.isArray(content)) return [];
      
      const cards = [];
      for (const block of content) {
        if (block.type === 'toolCall' && block.name === 'sessions_spawn') {
          const args = block.arguments || {};
          cards.push({
            id: block.id || `spawn-${Date.now()}`,
            task: args.task || 'Sub-agent task',
            label: args.label || null,
            model: args.model || null,
            agentId: args.agentId || null,
            timestamp: timestamp,
            // Result may come in a later tool_result block
            sessionKey: null, 
            status: 'running'
          });
        }
        // Check for tool results that might have spawn outcomes
        if (block.type === 'toolResult' && block.content) {
          try {
            const result = typeof block.content === 'string' ? JSON.parse(block.content) : block.content;
            if (result.sessionKey && result.sessionKey.includes(':subagent:')) {
              // Update corresponding card if we can find it
              const card = cards.find(c => c.id === block.toolCallId);
              if (card) {
                card.sessionKey = result.sessionKey;
                card.status = result.status || 'completed';
              }
            }
          } catch {}
        }
      }
      return cards;
    }
    
    // Render a spawn card HTML
    function renderSpawnCard(card, msgIdx) {
      const cardId = `spawn-${msgIdx}-${card.id}`;
      const statusClass = card.status === 'running' ? 'running' : 'completed';
      const statusText = card.status === 'running' ? 'ğŸ”„ Running' : 'âœ“ Done';
      const labelText = card.label ? ` (${escapeHtml(card.label)})` : '';
      const timeStr = card.timestamp ? formatMessageTime(new Date(card.timestamp)) : '';
      
      return `
        <div class="spawn-card" id="${cardId}" data-session-key="${escapeHtml(card.sessionKey || '')}">
          <div class="spawn-card-header" onclick="toggleSpawnCard('${cardId}')">
            <span class="spawn-card-icon">âš¡</span>
            <span class="spawn-card-title">Sub-agent spawned${labelText}</span>
            <span class="spawn-card-status ${statusClass}">${statusText}</span>
            <span class="spawn-card-expand">â–¼</span>
          </div>
          <div class="spawn-card-task">${escapeHtml(truncate(card.task, 150))}</div>
          <div class="spawn-card-body">
            <div class="spawn-card-messages" id="${cardId}-messages">
              <div class="spawn-card-loading">Click to load sub-agent transcript...</div>
            </div>
            ${card.sessionKey ? `<div class="spawn-card-link" onclick="openSession('${escapeHtml(card.sessionKey)}')">Open full session â†’</div>` : ''}
          </div>
          <div class="message-time">${timeStr}</div>
        </div>
      `;
    }
    
    // Toggle spawn card expansion and load transcript
    async function toggleSpawnCard(cardId) {
      const card = document.getElementById(cardId);
      if (!card) return;
      
      const wasExpanded = card.classList.contains('expanded');
      card.classList.toggle('expanded');
      
      // Load transcript on first expand
      if (!wasExpanded) {
        const sessionKey = card.dataset.sessionKey;
        const messagesEl = document.getElementById(`${cardId}-messages`);
        
        if (sessionKey && messagesEl && messagesEl.querySelector('.spawn-card-loading')) {
          messagesEl.innerHTML = '<div class="spawn-card-loading">Loading transcript...</div>';
          
          try {
            const resp = await rpc('chat.history', { sessionKey, limit: 50 });
            const messages = resp.messages || [];
            
            if (messages.length === 0) {
              messagesEl.innerHTML = '<div class="spawn-card-loading">No messages yet</div>';
            } else {
              messagesEl.innerHTML = messages.map((m, idx) => {
                const text = extractText(m.content);
                if (!text) return '';
                const roleClass = m.role === 'user' ? 'user' : 'assistant';
                if (roleClass === 'assistant') {
                  const shaped = shapeForDisplay(text);
                  if (shaped.suppressed) return '';
                  const replyChip = renderReplyChip(shaped.replyTo, idx - 1);
                  return `<div class="message ${roleClass}" data-message-idx="${idx}">${replyChip}<div class="message-content">${formatMessage(shaped.text)}</div></div>`;
                }
                return `<div class="message ${roleClass}" data-message-idx="${idx}"><div class="message-content">${formatMessage(text)}</div></div>`;
              }).filter(Boolean).join('');
            }
          } catch (err) {
            messagesEl.innerHTML = `<div class="spawn-card-loading">Failed to load: ${escapeHtml(err.message)}</div>`;
          }
        }
      }
    }
    
    function truncate(str, len) {
      if (!str) return '';
      return str.length > len ? str.slice(0, len) + '...' : str;
    }
    
    function extractText(content) {
      if (typeof content === 'string') return content;
      if (!Array.isArray(content)) return '';
      
      const textBlocks = content.filter(b => b.type === 'text');
      if (textBlocks.length > 0) {
        return textBlocks.map(b => b.text).join('\n');
      }
      
      if (content[0]?.text) return content[0].text;
      
      return '';
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MESSAGE SHAPING (reply tags + sentinel suppression)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function shapeForDisplay(rawText) {
      const shaper = window.messageShaping && window.messageShaping.shapeMessageText;
      if (!shaper) {
        return { text: String(rawText || ''), replyTo: null, suppressed: false, suppressedReason: null };
      }
      return shaper(String(rawText || ''));
    }

    function renderReplyChip(replyTo, fallbackTargetId) {
      if (!replyTo) return '';
      const label = replyTo.kind === 'current' ? 'Replying to: current' : `Replying to: ${escapeHtml(replyTo.id)}`;
      const ref = replyTo.kind === 'current' ? `idx:${escapeHtml(String(fallbackTargetId || ''))}` : `id:${escapeHtml(replyTo.id)}`;
      return `<div class="reply-chip" onclick="scrollToReplyRef('${ref}')" title="${label}">â†© ${escapeHtml(label)}</div>`;
    }

    function scrollToReplyRef(ref) {
      try {
        if (!ref) return;
        if (ref.startsWith('id:')) {
          const id = ref.slice(3);
          const el = document.querySelector(`[data-message-id='${CSS.escape(id)}']`);
          if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            el.classList.add('flash');
            setTimeout(() => el.classList.remove('flash'), 800);
            return;
          }
        }
        if (ref.startsWith('idx:')) {
          const idx = ref.slice(4);
          const el = document.querySelector(`[data-message-idx='${CSS.escape(idx)}']`);
          if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            el.classList.add('flash');
            setTimeout(() => el.classList.remove('flash'), 800);
            return;
          }
        }
        showToast('Replied-to message not found in loaded history', 'info');
      } catch (e) {
        // no-op
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUDIO RECORDING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function toggleRecording() {
      if (state.mediaRecorder && state.mediaRecorder.state === 'recording') {
        stopRecording();
      } else {
        startRecording();
      }
    }
    
    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Prefer webm/opus, fallback to other formats
        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
          ? 'audio/webm;codecs=opus'
          : MediaRecorder.isTypeSupported('audio/webm')
            ? 'audio/webm'
            : 'audio/mp4';
        
        state.mediaRecorder = new MediaRecorder(stream, { mimeType });
        state.audioChunks = [];
        
        state.mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            state.audioChunks.push(e.data);
          }
        };
        
        state.mediaRecorder.onstop = async () => {
          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());
          
          // Create blob from chunks
          const audioBlob = new Blob(state.audioChunks, { type: mimeType });
          const ext = mimeType.includes('webm') ? 'webm' : 'm4a';
          const audioFile = new File([audioBlob], `recording-${Date.now()}.${ext}`, { type: mimeType });
          
          // Add to media upload queue
          if (typeof MediaUpload !== 'undefined') {
            MediaUpload.addFiles([audioFile]);
          } else {
            showToast('Audio recorded but MediaUpload not available', 'warning');
          }
          
          // Reset state
          state.mediaRecorder = null;
          state.audioChunks = [];
        };
        
        state.mediaRecorder.start(1000); // Collect data every second
        state.recordingStartTime = Date.now();
        
        // Update UI
        const micBtn = document.getElementById('micBtn');
        const timer = document.getElementById('recordingTimer');
        micBtn.classList.add('recording');
        micBtn.title = 'Stop recording';
        timer.classList.add('visible');
        
        // Start timer display
        updateRecordingTimer();
        state.recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
        
        showToast('Recording started', 'info', 2000);
      } catch (err) {
        console.error('Failed to start recording:', err);
        if (err.name === 'NotAllowedError') {
          showToast('Microphone permission denied', 'error');
        } else {
          showToast('Failed to start recording: ' + err.message, 'error');
        }
      }
    }
    
    function stopRecording() {
      if (state.mediaRecorder && state.mediaRecorder.state === 'recording') {
        state.mediaRecorder.stop();
        
        // Update UI
        const micBtn = document.getElementById('micBtn');
        const timer = document.getElementById('recordingTimer');
        micBtn.classList.remove('recording');
        micBtn.title = 'Record audio';
        timer.classList.remove('visible');
        
        // Stop timer
        if (state.recordingTimerInterval) {
          clearInterval(state.recordingTimerInterval);
          state.recordingTimerInterval = null;
        }
        
        showToast('Recording stopped', 'info', 2000);
      }
    }
    
    function updateRecordingTimer() {
      const timer = document.getElementById('recordingTimer');
      if (!timer || !state.recordingStartTime) return;
      
      const elapsed = Math.floor((Date.now() - state.recordingStartTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      timer.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CHAT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      const hasMedia = typeof MediaUpload !== 'undefined' && MediaUpload.hasPendingFiles();
      
      // Need either text or media
      if (!text && !hasMedia) return;
      if (!state.currentSession) return;
      
      const sessionKey = state.currentSession.key;
      
      // If agent is busy, queue the message (text only for now)
      if (state.isThinking) {
        if (text) {
          state.messageQueue.push({ text, sessionKey });
          updateQueueIndicator();
          input.value = '';
          input.style.height = 'auto';
          addChatMessage('user queued', text);
        }
        return;
      }
      
      input.value = '';
      input.style.height = 'auto';
      
      // Handle OpenClaw-native attachments (chat.send.attachments)
      let finalMessage = text;
      let attachments = undefined;

      if (hasMedia) {
        try {
          attachments = await MediaUpload.buildGatewayAttachments();
          // Optional: show a simple placeholder in the chat log (we don't embed base64)
          if (!finalMessage) {
            const files = MediaUpload.getPendingFiles();
            finalMessage = files.map(f => `[attachment: ${f.file.name}]`).join('\n');
          }
          MediaUpload.clearFiles();
        } catch (err) {
          addChatMessage('system', `Attachment prep error: ${err.message}`);
          return;
        }
      }

      if (finalMessage || (attachments && attachments.length > 0)) {
        addChatMessage('user', finalMessage || '[attachment]');
        await processMessage(finalMessage || '', sessionKey, attachments);
      }
    }
    
    async function processMessage(text, sessionKey, attachments) {
      state.isThinking = true;
      setSessionStatus(sessionKey, 'thinking');
      updateSendButton();
      
      try {
        const idempotencyKey = `msg-${sessionKey}-${Date.now()}`;
        const result = await rpcCall('chat.send', {
          sessionKey: sessionKey,
          message: text,
          attachments: attachments,
          idempotencyKey
        }, 130000);
        
        if (result?.reply) {
          addChatMessage('assistant', result.reply);
        }
        
        setSessionStatus(sessionKey, 'idle');
        refresh();
        
      } catch (err) {
        addChatMessage('system', `Error: ${err.message}`);
        setSessionStatus(sessionKey, 'error');
      } finally {
        state.isThinking = false;
        updateSendButton();
        processNextInQueue();
      }
    }
    
    function processNextInQueue() {
      if (state.messageQueue.length === 0) return;
      
      const next = state.messageQueue.shift();
      updateQueueIndicator();
      
      // Convert queued message to regular
      const queuedMsgs = document.querySelectorAll('.message.user.queued');
      if (queuedMsgs.length > 0) {
        queuedMsgs[0].classList.remove('queued');
      }
      
      processMessage(next.text, next.sessionKey);
    }
    
    function updateQueueIndicator() {
      const indicator = document.getElementById('queueIndicator');
      const countEl = document.getElementById('queueCount');
      if (!indicator || !countEl) return;
      
      const count = state.messageQueue.length;
      countEl.textContent = count;
      indicator.classList.toggle('visible', count > 0);
    }
    
    function clearMessageQueue() {
      // Remove queued messages from UI
      document.querySelectorAll('.message.user.queued').forEach(el => el.remove());
      state.messageQueue = [];
      updateQueueIndicator();
    }
    
    function addChatMessage(role, content, timestamp = null) {
      const container = document.getElementById('chatMessages');
      const msg = document.createElement('div');
      msg.className = `message ${role}`;
      
      // Format content
      let contentHtml;
      let replyChip = '';
      const features = (config && config.features) ? config.features : {};
      const formatUserMessages = features.formatUserMessages === true;
      const shouldFormat = role.startsWith('assistant') || (formatUserMessages && role.startsWith('user'));

      if (role.startsWith('assistant') && !role.includes('thinking')) {
        const shaped = shapeForDisplay(content);
        if (shaped.suppressed) {
          return null; // do not render sentinel-only messages
        }
        replyChip = renderReplyChip(shaped.replyTo, container.children.length - 1);
        contentHtml = shouldFormat ? formatMessage(shaped.text) : escapeHtml(shaped.text);
      } else if (shouldFormat && !role.includes('thinking')) {
        contentHtml = formatMessage(content);
      } else {
        contentHtml = escapeHtml(content);
      }

      // Add timestamp
      const time = timestamp ? new Date(timestamp) : new Date();
      const timeStr = formatMessageTime(time);

      msg.setAttribute('data-message-idx', String(container.children.length));
      msg.innerHTML = `${replyChip}<div class="message-content">${contentHtml}</div><div class="message-time">${timeStr}</div>`;

      container.appendChild(msg);
      scrollChatToBottom();
      return msg;
    }
    
    function formatMessageTime(date) {
      const now = new Date();
      const isToday = date.toDateString() === now.toDateString();
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      const isYesterday = date.toDateString() === yesterday.toDateString();
      
      const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      if (isToday) {
        return timeStr;
      } else if (isYesterday) {
        return `Yesterday ${timeStr}`;
      } else {
        return date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + timeStr;
      }
    }
    
    function scrollChatToBottom() {
      const container = document.getElementById('chatMessages');
      if (container) {
        // Use requestAnimationFrame for reliable scrolling after DOM update
        requestAnimationFrame(() => {
          container.scrollTop = container.scrollHeight;
        });
      }
    }
    
    const AUDIO_EXTS = ['.mp3', '.wav', '.ogg', '.webm', '.m4a', '.mp4'];

    function sanitizeMediaUrl(rawUrl) {
      if (!rawUrl) return null;
      const trimmed = rawUrl.trim();

      // Always allow local uploads paths
      if (trimmed.startsWith('/apps/uploads/')) {
        return trimmed;
      }

      // Back-compat: /uploads/* served by OpenClaw apps â†’ rewrite
      if (trimmed.startsWith('/uploads/')) {
        return `/apps${trimmed}`;
      }

      // External media is optional (off by default for safer fresh installs)
      const features = (config && config.features) ? config.features : {};
      const allowExternalMedia = features.allowExternalMedia === true;

      if (/^https?:\/\//i.test(trimmed)) {
        if (!allowExternalMedia) return null;
        try {
          const parsed = new URL(trimmed);
          if (parsed.protocol === 'http:' || parsed.protocol === 'https:') {
            return parsed.href;
          }
        } catch (err) {
          return null;
        }
      }

      return null;
    }

    function isAudioName(name) {
      if (!name) return false;
      const clean = name.split('?')[0].split('#')[0].toLowerCase();
      return AUDIO_EXTS.some(ext => clean.endsWith(ext));
    }

    function tokenizeMediaMarkdown(text) {
      const tokens = [];
      const addToken = (html) => {
        const token = `@@MEDIA_${tokens.length}@@`;
        tokens.push(html);
        return token;
      };

      let processed = text;

      const audioReplacement = (match, url) => {
        const safeUrl = sanitizeMediaUrl(url);
        if (!safeUrl) return match;
        if (!isAudioName(safeUrl)) return match;
        return addToken(`<audio class="chat-audio" controls src="${escapeHtml(safeUrl)}"></audio>`);
      };

      processed = processed.replace(/!\[audio[^\]]*\]\(([^)]+)\)/gi, audioReplacement);
      processed = processed.replace(/!audio\(([^)]+)\)/gi, audioReplacement);

      processed = processed.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, altText, url) => {
        const safeUrl = sanitizeMediaUrl(url);
        if (!safeUrl) return match;
        const safeAlt = escapeHtml(altText || '');
        return addToken(`<img class="chat-image" src="${escapeHtml(safeUrl)}" alt="${safeAlt}" loading="lazy">`);
      });

      // Audio links: [label](url)
      processed = processed.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, label, url) => {
        const safeUrl = sanitizeMediaUrl(url);
        if (!safeUrl) return match;
        if (isAudioName(safeUrl)) {
          return addToken(`<audio class="chat-audio" controls src="${escapeHtml(safeUrl)}"></audio>`);
        }
        return addToken(`<a href="${escapeHtml(safeUrl)}" target="_blank" rel="noopener">${escapeHtml(label)}</a>`);
      });

      // Attachment placeholders: [attachment: filename]
      processed = processed.replace(/\[attachment:\s*([^\]]+)\]/gi, (match, name) => {
        const trimmed = name.trim();
        if (isAudioName(trimmed)) {
          const safeUrl = sanitizeMediaUrl(trimmed);
          if (safeUrl) {
            return addToken(`<audio class="chat-audio" controls src="${escapeHtml(safeUrl)}"></audio>`);
          }
          return addToken(`<span class="chat-attachment audio">ğŸµ ${escapeHtml(trimmed)}</span>`);
        }
        return addToken(`<span class="chat-attachment">ğŸ“ ${escapeHtml(trimmed)}</span>`);
      });

      return { processed, tokens };
    }
    
    // Configure marked for chat rendering
    if (typeof marked !== 'undefined') {
      const renderer = {
        link(token) {
          const href = token.href || '';
          const text = token.text || href;
          return '<a href="' + href + '" target="_blank" rel="noopener">' + text + '</a>';
        },
        code(token) {
          const code = token.text || '';
          const lang = (token.lang || '').trim();
          if (lang && typeof Prism !== 'undefined') {
            const grammar = Prism.languages[lang];
            if (grammar) {
              const highlighted = Prism.highlight(code, grammar, lang);
              return '<pre class="language-' + lang + '"><code class="language-' + lang + '">' + highlighted + '</code></pre>';
            }
          }
          return '<pre><code>' + code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</code></pre>';
        }
      };
      if (marked.use) marked.use({ breaks: true, gfm: true, renderer });
      else if (marked.setOptions) marked.setOptions({ breaks: true, gfm: true, renderer });
    }

    function formatMessage(text) {
      const { processed, tokens } = tokenizeMediaMarkdown(text);
      let html;
      if (typeof marked !== 'undefined') {
        html = marked.parse(processed);
      } else {
        // Fallback if marked fails to load
        html = escapeHtml(processed)
          .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
          .replace(/`([^`]+)`/g, '<code>$1</code>')
          .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
          .replace(/\*([^*]+)\*/g, '<em>$1</em>')
          .replace(/\n/g, '<br>');
      }
      tokens.forEach((tokenHtml, idx) => {
        html = html.replace(`@@MEDIA_${idx}@@`, tokenHtml);
      });
      return html;
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      // Also escape single quotes for use in single-quoted attributes (onclick handlers)
      return div.innerHTML.replace(/'/g, '&#39;');
    }
    
    function handleChatKey(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
      if (e.key === 'Escape' && state.isThinking) {
        e.preventDefault();
        stopAgent();
      }
    }
    
    function autoResize(el) {
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 200) + 'px';
    }
    
    function updateSendButton() {
      document.getElementById('sendBtn').disabled = state.isThinking;
      const stopBtn = document.getElementById('stopBtn');
      if (stopBtn) stopBtn.disabled = !state.isThinking;
    }
    
    function updateVerboseToggleUI() {
      const wrap = document.getElementById('verboseToggle');
      if (!wrap) return;
      const key = state.currentSession?.key;
      const level = (key && state.verboseBySession[key]) ? state.verboseBySession[key] : 'off';
      wrap.querySelectorAll('.verbose-btn').forEach(btn => {
        const v = btn.getAttribute('data-verbose');
        btn.classList.toggle('active', v === level);
      });
    }

    async function setVerboseMode(level) {
      if (!state.currentSession) return;
      const key = state.currentSession.key;
      const normalized = (level === 'full' || level === 'on' || level === 'off') ? level : 'off';

      // Persist for UI purposes (server-side is authoritative, but this keeps UX stable)
      state.verboseBySession[key] = normalized;
      localStorage.setItem('sharp_verbose_by_session', JSON.stringify(state.verboseBySession));
      updateVerboseToggleUI();

      try {
        const idempotencyKey = `verbose-${key}-${Date.now()}`;
        await rpcCall('chat.send', {
          sessionKey: key,
          message: `/verbose ${normalized}`,
          idempotencyKey
        }, 10000);
        addChatMessage('system', `Verbose â†’ ${normalized}`);
      } catch (err) {
        addChatMessage('system', `Failed to set verbose: ${err.message}`);
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MODEL SELECTOR (per session)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function availableModelChoices() {
      const base = [
        { value: 'default', label: 'default' },
        { value: 'gpt', label: 'gpt (gpt-5.2 alias)' },
        { value: 'opus', label: 'opus (Claude Opus alias)' },
      ];
      const seen = new Set(base.map(x => x.value));
      for (const a of (state.agents || [])) {
        const m = String(a?.model || a?.models?.primary || '').trim();
        if (!m) continue;
        if (seen.has(m)) continue;
        seen.add(m);
        base.push({ value: m, label: m });
      }
      const head = base.slice(0, 3);
      const tail = base.slice(3).sort((a, b) => a.label.localeCompare(b.label));
      return head.concat(tail).concat([{ value: '__custom__', label: 'Customâ€¦' }]);
    }

    function effectiveSessionModel(session) {
      if (!session?.key) return session?.model || null;
      return state.sessionModelOverrides?.[session.key] || session.model || null;
    }

    function renderSessionModelSelector(session) {
      const sel = document.getElementById('sessionModelSelect');
      if (!sel) return;

      const choices = availableModelChoices();
      const current = effectiveSessionModel(session);
      const currentValue = current || 'default';

      sel.innerHTML = choices.map(c => {
        const selected = (c.value === currentValue) ? ' selected' : '';
        return `<option value="${escapeHtml(String(c.value))}"${selected}>${escapeHtml(String(c.label))}</option>`;
      }).join('');

      if (current && !choices.some(c => c.value === current)) {
        const opt = document.createElement('option');
        opt.value = String(current);
        opt.textContent = String(current);
        opt.selected = true;
        sel.insertBefore(opt, sel.firstChild);
      }
    }

    async function handleSessionModelChange(value) {
      const sessionKey = state.currentSession?.key;
      if (!sessionKey) return;

      let chosen = String(value || '').trim();
      if (!chosen) return;

      if (chosen === '__custom__') {
        const custom = prompt('Enter model alias or full model id (e.g. opus, gpt, anthropic/claude-opus-4-5):', 'opus');
        if (!custom) {
          renderSessionModelSelector(state.currentSession);
          return;
        }
        chosen = String(custom).trim();
      }

      const prev = effectiveSessionModel(state.currentSession) || 'default';
      if (chosen === prev) return;

      const ok = confirm(`Switch model to "${chosen}"?\n\nThis will reset the session (equivalent to sending: /new ${chosen}).`);
      if (!ok) {
        renderSessionModelSelector(state.currentSession);
        return;
      }

      state.sessionModelOverrides[sessionKey] = chosen;
      lsSet('session_model_overrides', JSON.stringify(state.sessionModelOverrides));
      renderSessionModelSelector(state.currentSession);

      try {
        const idempotencyKey = `model-${sessionKey}-${Date.now()}`;
        await rpcCall('chat.send', {
          sessionKey,
          message: `/new ${chosen}`,
          idempotencyKey,
        }, 15000);
        showToast(`Model â†’ ${chosen} (session reset)`, 'success', 2500);

        setTimeout(async () => {
          try {
            await loadSessions();
            const updated = state.sessions.find(s => s.key === sessionKey);
            if (updated) state.currentSession = updated;
            renderSessionModelSelector(state.currentSession);
            renderSessions();
          } catch {}
        }, 1200);
      } catch (err) {
        showToast(`Failed to switch model: ${err.message}`, 'error');
      }
    }

    async function stopAgent() {
      if (!state.isThinking || !state.currentSession) return;
      
      try {
        const idempotencyKey = `stop-${state.currentSession.key}-${Date.now()}`;
        await rpcCall('chat.send', {
          sessionKey: state.currentSession.key,
          message: '/stop',
          idempotencyKey
        }, 10000);
        addChatMessage('system', 'â¹ Stop requested');
      } catch (err) {
        addChatMessage('system', `Failed to stop: ${err.message}`);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXPORT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function buildChatMarkdown(messages) {
      const sessionName = getSessionName(state.currentSession);
      const timestamp = new Date().toISOString();

      let md = `# Chat Export: ${sessionName}\n`;
      md += `Exported: ${timestamp}\n\n`;
      md += `---\n\n`;

      for (const msg of messages) {
        const role = msg.role === 'user' ? 'User' : 'Assistant';
        md += `## ${role}\n\n`;

        if (typeof msg.content === 'string') {
          md += msg.content + '\n\n';
        } else if (Array.isArray(msg.content)) {
          for (const block of msg.content) {
            if (block.type === 'text') {
              md += block.text + '\n\n';
            } else if (block.type === 'tool_use') {
              md += `\`\`\`tool_call: ${block.name}\n`;
              md += JSON.stringify(block.input, null, 2) + '\n';
              md += `\`\`\`\n\n`;
            } else if (block.type === 'tool_result') {
              const content = typeof block.content === 'string'
                ? block.content
                : JSON.stringify(block.content, null, 2);
              const preview = content.length > 500
                ? content.slice(0, 500) + '...'
                : content;
              md += `\`\`\`tool_result\n${preview}\n\`\`\`\n\n`;
            } else if (block.type === 'image') {
              md += `[Image: ${block.source?.media_type || 'image'}]\n\n`;
            }
          }
        }

        md += `---\n\n`;
      }

      return md;
    }

    async function fetchChatMessages() {
      const result = await rpcCall('chat.history', {
        sessionKey: state.currentSession.key,
        limit: 500
      });
      return result?.messages || [];
    }

    async function exportChatAsMarkdown() {
      if (!state.currentSession) return;

      try {
        const messages = await fetchChatMessages();
        if (!messages.length) {
          showToast('No messages to export', 'info');
          return;
        }

        const md = buildChatMarkdown(messages);
        const dateStr = new Date().toISOString().split('T')[0];
        const safeKey = state.currentSession.key
          .replace(/[^a-zA-Z0-9-_]/g, '-')
          .replace(/-+/g, '-')
          .slice(0, 50);
        const filename = `chat-${safeKey}-${dateStr}.md`;

        // Primary: File System Access API (Chrome/Edge 86+ over HTTPS)
        if (window.showSaveFilePicker) {
          const handle = await window.showSaveFilePicker({
            suggestedName: filename,
            types: [{ description: 'Markdown', accept: { 'text/markdown': ['.md'] } }],
          });
          const writable = await handle.createWritable();
          await writable.write(md);
          await writable.close();
          showToast('Exported!', 'success', 1500);
          return;
        }

        // Fallback: POST to /api/export which returns Content-Disposition header
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = '/api/export';
        form.style.display = 'none';
        const fInput = document.createElement('input');
        fInput.type = 'hidden';
        fInput.name = 'filename';
        fInput.value = filename;
        form.appendChild(fInput);
        const cInput = document.createElement('textarea');
        cInput.name = 'content';
        cInput.textContent = md;
        form.appendChild(cInput);
        document.body.appendChild(form);
        form.submit();
        document.body.removeChild(form);

      } catch (err) {
        if (err.name === 'AbortError') return;
        console.error('Export failed:', err);
        showToast('Export failed: ' + err.message, 'error');
      }
    }

    async function copyChatAsMarkdown() {
      if (!state.currentSession) return;
      try {
        const messages = await fetchChatMessages();
        if (!messages.length) {
          showToast('No messages to copy', 'info');
          return;
        }
        await copyToClipboard(buildChatMarkdown(messages));
        showToast('Copied to clipboard', 'success', 1500);
      } catch (err) {
        console.error('Copy failed:', err);
        showToast('Copy failed: ' + err.message, 'error');
      }
    }

    function headerAction() {
      if (state.currentSession?.key === 'agent:main:main') {
        if (confirm('Start a new session? This will reset the conversation.')) {
          sendMessage('/new');
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MULTI-SELECT MODE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function enterMultiSelect() {
      state.multiSelectMode = true;
      state.selectedSessions.clear();
      const sl = document.getElementById('sessionsList');
      if (sl) sl.classList.add('multi-select-mode');
      renderSessions();
    }

    function exitMultiSelect() {
      state.multiSelectMode = false;
      state.selectedSessions.clear();
      const sl = document.getElementById('sessionsList');
      if (sl) sl.classList.remove('multi-select-mode');
      renderSessions();
    }
    
    function toggleSessionSelection(key, event) {
      if (event) {
        event.stopPropagation();
      }
      
      if (state.selectedSessions.has(key)) {
        state.selectedSessions.delete(key);
      } else {
        state.selectedSessions.add(key);
      }
      
      updateBulkActionBar();
      updateCheckboxStates();
    }
    
    function toggleSelectAll() {
      const mainSessions = state.sessions.filter(s => !s.key.includes(':subagent:'));
      
      if (state.selectedSessions.size === mainSessions.length) {
        // Deselect all
        state.selectedSessions.clear();
      } else {
        // Select all
        mainSessions.forEach(s => state.selectedSessions.add(s.key));
      }
      
      updateBulkActionBar();
      updateCheckboxStates();
    }
    
    function updateBulkActionBar() {
      // Bulk action bar has been removed from sidebar
    }
    
    function updateCheckboxStates() {
      // Update individual checkboxes
      document.querySelectorAll('.session-checkbox[data-key]').forEach(checkbox => {
        const key = checkbox.dataset.key;
        if (state.selectedSessions.has(key)) {
          checkbox.classList.add('checked');
        } else {
          checkbox.classList.remove('checked');
        }
      });
      
      // Update select all checkbox
      const mainSessions = state.sessions.filter(s => !s.key.includes(':subagent:'));
      const selectAllCheckbox = document.getElementById('selectAllCheckbox');
      if (selectAllCheckbox) {
        if (mainSessions.length > 0 && state.selectedSessions.size === mainSessions.length) {
          selectAllCheckbox.classList.add('checked');
        } else {
          selectAllCheckbox.classList.remove('checked');
        }
      }
    }
    
    async function bulkPin() {
      if (state.selectedSessions.size === 0) return;
      
      const keys = [...state.selectedSessions];
      let pinned = 0;
      
      for (const key of keys) {
        try {
          await rpcCall('sessions.pin', { sessionKey: key, pinned: true });
          pinned++;
        } catch (err) {
          console.error(`Failed to pin ${key}:`, err);
        }
      }
      
      exitMultiSelect();
      await refresh();
      
      console.log(`[ClawCondos] Pinned ${pinned}/${keys.length} sessions`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // OVERVIEW
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function updateOverview() {
      renderRecentSessions();
      updateStatsGrid();
    }


    function renderCondoStatusBoard() {
      const container = document.getElementById('condoStatusBoard');
      const countEl = document.getElementById('condoCount');
      if (!container) return;

      const { grouped, uncategorized } = groupGoalsByCondoId();

      // Build condo entries with their goals
      const condoEntries = (state.condos || [])
        .filter(c => grouped[c.id] && grouped[c.id].length)
        .map(c => ({ condo: c, goals: grouped[c.id] }))
        .sort((a, b) => getCondoLatestActivity(b.condo, b.goals) - getCondoLatestActivity(a.condo, a.goals));

      const totalCondos = condoEntries.length + (uncategorized.length ? 1 : 0);
      if (countEl) countEl.textContent = totalCondos;

      if (!totalCondos && !state.goals.length) {
        // All values escaped via escapeHtml()
        container.innerHTML =
          '<div class="condo-status-card empty" onclick="showCreateGoalModal()" style="border-style: dashed; opacity: 0.6; cursor: pointer; padding: 24px; text-align: center;">' +
            '<div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 4px;">Create your first condo</div>' +
            '<div style="color: var(--text-dim); font-size: 0.85rem;">Organize goals, tasks, and sessions into projects.</div>' +
          '</div>';
        return;
      }

      // All user-generated content is escaped via escapeHtml() before insertion
      const cards = [];

      for (const { condo, goals } of condoEntries) {
        goals.sort((a, b) => getGoalLatestActivity(b) - getGoalLatestActivity(a));
        const attention = getCondoAttention(condo, goals);
        // Count active sessions across all goals in this condo
        var activeSessions = 0;
        var totalSessions = 0;
        goals.forEach(function(g) {
          (g.sessions || []).forEach(function(sk) {
            totalSessions++;
            if (getAgentStatus(sk) === 'thinking') activeSessions++;
          });
        });
        cards.push(renderCondoCard(condo.name || 'Unnamed condo', goals, attention, activeSessions, totalSessions));
      }

      // Uncategorized goals
      if (uncategorized.length) {
        uncategorized.sort((a, b) => getGoalLatestActivity(b) - getGoalLatestActivity(a));
        var uncatActiveSessions = 0;
        var uncatTotalSessions = 0;
        uncategorized.forEach(function(g) {
          (g.sessions || []).forEach(function(sk) {
            uncatTotalSessions++;
            if (getAgentStatus(sk) === 'thinking') uncatActiveSessions++;
          });
        });
        cards.push(renderCondoCard('Uncategorized', uncategorized, 'none', uncatActiveSessions, uncatTotalSessions));
      }

      container.innerHTML = cards.join('');
    }

    function renderCondoCard(condoName, goals, attention, activeSessions, totalSessions) {
      const attentionBorder = attention === 'needs-input' ? ' condo-attention-needs-input'
        : attention === 'unread' ? ' condo-attention-unread' : '';

      // Separate active and done goals
      const activeGoals = goals.filter(function(g) { return g.status !== 'done'; });
      const doneGoals = goals.filter(function(g) { return g.status === 'done'; });

      const goalRows = activeGoals.map(function(g) {
        return renderGoalRow(g);
      }).join('');

      // Done goals collapsed summary
      const doneSummary = doneGoals.length > 0
        ? '<div class="condo-done-summary">' + doneGoals.length + ' completed goal' + (doneGoals.length !== 1 ? 's' : '') + '</div>'
        : '';

      // Header stats
      const headerStats = [];
      headerStats.push(activeGoals.length + ' active');
      if (doneGoals.length) headerStats.push(doneGoals.length + ' done');
      if (activeSessions > 0) headerStats.push(activeSessions + ' running');

      return '<div class="condo-status-card' + attentionBorder + '">' +
        '<div class="condo-status-header">' +
          '<div class="condo-status-header-left">' +
            '<span class="condo-status-name">' + escapeHtml(condoName) + '</span>' +
            (activeSessions > 0 ? '<span class="condo-running-badge">' + activeSessions + ' running</span>' : '') +
          '</div>' +
          '<span class="condo-status-count">' + headerStats.join(' \u00b7 ') + '</span>' +
        '</div>' +
        '<div class="condo-status-goals">' + goalRows + doneSummary + '</div>' +
      '</div>';
    }

    function renderGoalRow(g) {
      const { done, total } = goalTaskStats(g);
      const pct = total ? Math.round((done / total) * 100) : 0;
      const latestSession = getGoalLatestSession(g);
      const agentStatus = latestSession ? getAgentStatus(latestSession.key) : 'idle';
      const preview = latestSession ? getMessagePreview(latestSession) : '';
      const goalAttention = getGoalAttention(g);
      const pr = g.priority ? '<span class="goal-pill pr">' + escapeHtml(g.priority) + '</span>' : '';
      const rowAttention = goalAttention === 'needs-input' ? ' goal-row-needs-input'
        : goalAttention === 'unread' ? ' goal-row-unread' : '';
      const isThinking = agentStatus === 'thinking';
      const sessionCount = Array.isArray(g.sessions) ? g.sessions.length : 0;

      return '<div class="goal-status-row' + rowAttention + (isThinking ? ' goal-row-thinking' : '') + '" onclick="openGoalPanel(\'' + escapeHtml(g.id) + '\')">' +
        '<div class="goal-row-left">' +
          '<div class="agent-status ' + agentStatus + '" style="width: 8px; height: 8px; flex-shrink: 0;"></div>' +
          '<div class="goal-row-info">' +
            '<div class="goal-row-title">' + escapeHtml(g.title || 'Untitled goal') + ' ' + pr + '</div>' +
            '<div class="goal-row-meta">' +
              (total > 0 ? '<span>' + done + '/' + total + ' tasks</span>' : '') +
              (sessionCount > 0 ? '<span>' + sessionCount + ' session' + (sessionCount !== 1 ? 's' : '') + '</span>' : '') +
              '<span>' + timeAgo(getGoalLatestActivity(g)) + '</span>' +
            '</div>' +
          '</div>' +
        '</div>' +
        (preview ? '<div class="goal-row-preview">' + escapeHtml(preview) + '</div>' : '') +
        (total > 0 ? '<div class="goal-row-progress"><div class="goal-row-progress-bar' + (isThinking ? ' thinking' : '') + '" style="width:' + pct + '%;"></div></div>' : '') +
      '</div>';
    }

    function renderRecentSessions() {
      const section = document.getElementById('recentActivitySection');
      const container = document.getElementById('recentSessionsGrid');
      const countEl = document.getElementById('recentSessionCount');
      if (!container || !section) return;

      // Show ALL recent sessions (top 20), sorted by updatedAt, excluding subagents
      const recentSessions = state.sessions
        .filter(s => !s.key.includes(':subagent:'))
        .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))
        .slice(0, 20);

      if (countEl) countEl.textContent = recentSessions.length;

      if (!recentSessions.length) {
        // Static safe HTML â€” no user content
        container.innerHTML = '<div class="session-card" style="border-style:dashed;opacity:.6"><div class="card-top"><div class="card-icon">\uD83D\uDCAC</div><div class="card-info"><div class="card-name">No recent sessions</div><div class="card-desc">Start a conversation to see it here</div></div></div></div>';
        return;
      }

      // All user-generated content is escaped via escapeHtml() before insertion
      container.innerHTML = recentSessions.map(function(s) {
        var preview = getMessagePreview(s);
        var agentStatus = getAgentStatus(s.key);
        var tooltip = getStatusTooltip(agentStatus);
        var hasUnread = isSessionUnread(s.key);
        var needsInput = hasUnread && (agentStatus === 'idle' || agentStatus === 'error');
        var attentionClass = needsInput ? 'needs-input' : (hasUnread ? 'unread' : '');

        // Show condo badge if session belongs to a goal
        var goal = getGoalForSession(s.key);
        var condoBadge = goal
          ? '<span class="card-badge goal" onclick="event.stopPropagation(); openGoal(\'' + escapeHtml(goal.id) + '\')">' + escapeHtml(goal.condoName || goal.title || 'Goal') + '</span>'
          : '';

        return '<div class="session-card ' + (attentionClass ? 'card-attention-' + attentionClass : '') + '" onclick="openDetailPanel(\'' + escapeHtml(s.key) + '\')">' +
          '<div class="card-top">' +
            (attentionClass ? '<div class="card-attention ' + attentionClass + '"></div>' : '') +
            '<div class="card-icon">' + getSessionIcon(s) + '</div>' +
            '<div class="card-info">' +
              '<div class="card-name">' + escapeHtml(getSessionName(s)) + '</div>' +
              '<div class="card-desc">' + escapeHtml(s.model ? s.model.split('/').pop() : 'unknown model') + '</div>' +
            '</div>' +
          '</div>' +
          (preview ? '<div class="card-preview">' + escapeHtml(preview) + '</div>' : '') +
          '<div class="card-footer">' +
            '<span>' + timeAgo(s.updatedAt) + '</span>' +
            '<span class="card-footer-right">' + condoBadge + '<span class="card-badge">' + (s.totalTokens || 0).toLocaleString() + ' tokens</span></span>' +
          '</div>' +
        '</div>';
      }).join('');
    }

    // Keep old function names as aliases for straggling call sites
    function renderGoalsGrid() { renderRecentSessions(); }
    function renderSessionsGrid() { renderRecentSessions(); }
    
    function renderAppsGrid() {
      const container = document.getElementById('appsGrid');
      if (!container) return;
      const countEl = document.getElementById('appCount');
      if (countEl) countEl.textContent = state.apps.length;
      
      if (state.apps.length === 0) {
        container.innerHTML = `
          <div class="app-card" style="border-style: dashed; opacity: 0.6;">
            <div class="card-top">
              <div class="card-icon">ğŸ“¦</div>
              <div class="card-info">
                <div class="card-name">No apps configured</div>
                <div class="card-desc">Add apps to apps.json</div>
              </div>
            </div>
          </div>
        `;
        return;
      }
      
      container.innerHTML = state.apps.map(app => `
        <a href="/app?id=${escapeHtml(app.id)}" target="_blank" class="app-card" style="text-decoration: none; color: inherit;">
          <div class="card-top">
            <div class="card-icon">${escapeHtml(app.icon || 'ğŸ“¦')}</div>
            <div class="card-info">
              <div class="card-name">${escapeHtml(app.name)}</div>
              <div class="card-desc">${escapeHtml(app.description || '')}</div>
            </div>
            <div class="card-status-dot idle" id="app-grid-status-${escapeHtml(app.id)}" title="Checking..."></div>
          </div>
          <div class="card-footer">
            <span>Port ${app.port}</span>
            <span class="card-badge">${escapeHtml(app.id)}</span>
          </div>
        </a>
      `).join('');
      
      state.apps.forEach(app => {
        checkAppGridStatus(app);
      });
    }
    
    async function checkAppGridStatus(app) {
      const dot = document.getElementById(`app-grid-status-${app.id}`);
      if (!dot) return;
      
      try {
        const res = await fetch(`/${app.id}/`, { method: 'HEAD' });
        const ok = res.ok || res.status === 401;
        dot.className = 'card-status-dot ' + (ok ? 'active' : 'error');
        dot.title = ok ? 'App is running' : 'App is not responding';
      } catch {
        dot.className = 'card-status-dot error';
        dot.title = 'App is not responding';
      }
    }
    
    function renderSubagentsGrid() {
      const subagents = state.sessions.filter(s => s.key.includes(':subagent:'));
      const section = document.getElementById('subagentsSection');
      const container = document.getElementById('subagentsGrid');
      if (!section || !container) return;
      const countEl = document.getElementById('taskCount');
      if (countEl) countEl.textContent = subagents.length;

      if (subagents.length === 0) {
        section.style.display = 'none';
        return;
      }
      
      section.style.display = 'block';
      
      container.innerHTML = subagents.map(s => {
        const preview = getMessagePreview(s);
        const agentStatus = getAgentStatus(s.key);
        const tooltip = getStatusTooltip(agentStatus);
        return `
          <div class="session-card" onclick="openSession('${escapeHtml(s.key)}')">
            <div class="card-top">
              <div class="card-icon">âš¡</div>
              <div class="card-info">
                <div class="card-name">${escapeHtml(s.label || 'Sub-agent')}</div>
                <div class="card-desc">${escapeHtml(s.model?.split('/').pop() || 'unknown')}</div>
              </div>
              <div class="agent-status ${agentStatus}" data-tooltip="${tooltip}" style="width: 10px; height: 10px;"></div>
            </div>
            ${preview ? `<div class="card-preview">${escapeHtml(preview)}</div>` : ''}
            <div class="card-footer">
              <span>${timeAgo(s.updatedAt)}</span>
            </div>
          </div>
        `;
      }).join('');
    }
    
    function getMessagePreview(s) {
      if (s.messages?.[0]) {
        const msg = s.messages[0];
        const text = extractText(msg.content);
        if (text) return text.slice(0, 100) + (text.length > 100 ? '...' : '');
      }
      return '';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITIES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function timeAgo(ts) {
      const diff = Date.now() - ts;
      const mins = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (mins < 1) return 'just now';
      if (mins < 60) return `${mins}m ago`;
      if (hours < 24) return `${hours}h ago`;
      return `${days}d ago`;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SEARCH PALETTE (Cmd+K)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let _searchDebounceTimer = null;
    let _searchRequestId = 0;
    let _searchSelectedIdx = -1;
    let _searchResults = []; // flat array of { type, data }

    function openSearchPalette() {
      const overlay = document.getElementById('searchPalette');
      overlay.classList.remove('hidden');
      const input = document.getElementById('searchPaletteInput');
      input.value = '';
      input.focus();
      _searchSelectedIdx = -1;
      _searchResults = [];
      showRecentItems();
    }

    function closeSearchPalette() {
      document.getElementById('searchPalette').classList.add('hidden');
      _searchSelectedIdx = -1;
      _searchResults = [];
    }

    function toggleSearchPalette() {
      const overlay = document.getElementById('searchPalette');
      if (overlay.classList.contains('hidden')) {
        openSearchPalette();
      } else {
        closeSearchPalette();
      }
    }

    function showRecentItems() {
      const recentGoals = (state.goals || [])
        .slice()
        .sort((a, b) => (b.updatedAtMs || 0) - (a.updatedAtMs || 0))
        .slice(0, 5);
      const recentSessions = (state.sessions || [])
        .slice()
        .sort((a, b) => {
          const ta = a.updatedAt ? new Date(a.updatedAt).getTime() : 0;
          const tb = b.updatedAt ? new Date(b.updatedAt).getTime() : 0;
          return tb - ta;
        })
        .slice(0, 5);
      renderSearchPaletteResults(recentGoals, recentSessions, true);
    }

    function onSearchPaletteInput() {
      const query = document.getElementById('searchPaletteInput').value.trim();
      clearTimeout(_searchDebounceTimer);

      if (!query) {
        _searchRequestId++;
        showRecentItems();
        return;
      }

      _searchDebounceTimer = setTimeout(() => {
        const reqId = ++_searchRequestId;
        fetch('/api/search?q=' + encodeURIComponent(query) + '&limit=20')
          .then(r => r.json())
          .then(data => {
            if (reqId !== _searchRequestId) return; // stale
            if (data.ok) {
              renderSearchPaletteResults(data.goals || [], data.sessions || [], false);
            } else {
              showSearchError('Search failed');
            }
          })
          .catch(() => {
            if (reqId !== _searchRequestId) return;
            showSearchError('Search unavailable');
          });
      }, 200);
    }

    function showSearchError(msg) {
      const el = document.getElementById('searchPaletteResults');
      el.textContent = '';
      const div = document.createElement('div');
      div.className = 'search-palette-error';
      div.textContent = msg;
      el.appendChild(div);
    }

    function renderSearchPaletteResults(goals, sessions, isRecent) {
      _searchResults = [];
      const container = document.getElementById('searchPaletteResults');
      container.textContent = '';
      const goalLabel = isRecent ? 'Recent Goals' : 'Goals';
      const sessionLabel = isRecent ? 'Recent Sessions' : 'Sessions';

      if (goals.length > 0) {
        const header = document.createElement('div');
        header.className = 'search-palette-section';
        header.textContent = goalLabel;
        container.appendChild(header);

        goals.forEach(g => {
          const idx = _searchResults.length;
          _searchResults.push({ type: 'goal', data: g });
          const stats = goalTaskStats(g);
          container.appendChild(buildSearchItem(idx,
            g.status === 'done' ? '\u2705' : '\uD83C\uDFAF',
            g.title || 'Untitled',
            stats.total > 0 ? stats.done + '/' + stats.total + ' tasks' : ''
          ));
        });
      }

      if (sessions.length > 0) {
        const header = document.createElement('div');
        header.className = 'search-palette-section';
        header.textContent = sessionLabel;
        container.appendChild(header);

        sessions.forEach(s => {
          const idx = _searchResults.length;
          _searchResults.push({ type: 'session', data: s });
          const parentGoal = getGoalForSession(s.key);
          container.appendChild(buildSearchItem(idx,
            getSessionIcon(s),
            getSessionName(s),
            parentGoal ? parentGoal.title : s.key
          ));
        });
      }

      if (!goals.length && !sessions.length) {
        const empty = document.createElement('div');
        empty.className = 'search-palette-empty';
        empty.textContent = 'No results found';
        container.appendChild(empty);
      }

      _searchSelectedIdx = -1;
    }

    function buildSearchItem(idx, icon, name, meta) {
      const item = document.createElement('div');
      item.className = 'search-palette-item';
      item.dataset.idx = idx;
      item.onclick = () => selectSearchResult(idx);
      item.onmouseenter = () => highlightSearchResult(idx);

      const iconEl = document.createElement('span');
      iconEl.className = 'search-palette-item-icon';
      iconEl.textContent = icon;
      item.appendChild(iconEl);

      const info = document.createElement('div');
      info.className = 'search-palette-item-info';

      const nameEl = document.createElement('div');
      nameEl.className = 'search-palette-item-name';
      nameEl.textContent = name;
      info.appendChild(nameEl);

      if (meta) {
        const metaEl = document.createElement('div');
        metaEl.className = 'search-palette-item-meta';
        metaEl.textContent = meta;
        info.appendChild(metaEl);
      }

      item.appendChild(info);
      return item;
    }

    function highlightSearchResult(idx) {
      _searchSelectedIdx = idx;
      document.querySelectorAll('.search-palette-item').forEach(el => {
        el.classList.toggle('selected', parseInt(el.dataset.idx) === idx);
      });
    }

    function selectSearchResult(idx) {
      const entry = _searchResults[idx];
      if (!entry) return;
      closeSearchPalette();

      if (entry.type === 'goal') {
        openGoal(entry.data.id);
      } else if (entry.type === 'session') {
        // Inject session into state.sessions if not present (handles sessions beyond the client's 50)
        const existing = state.sessions.find(s => s.key === entry.data.key);
        if (!existing) {
          state.sessions.push(entry.data);
        }
        openSession(entry.data.key);
      }
    }

    function handleSearchPaletteKey(e) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const next = _searchSelectedIdx + 1;
        if (next < _searchResults.length) highlightSearchResult(next);
        else if (_searchResults.length > 0) highlightSearchResult(0);
        scrollSelectedIntoView();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prev = _searchSelectedIdx - 1;
        if (prev >= 0) highlightSearchResult(prev);
        else if (_searchResults.length > 0) highlightSearchResult(_searchResults.length - 1);
        scrollSelectedIntoView();
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (_searchSelectedIdx >= 0) {
          selectSearchResult(_searchSelectedIdx);
        }
      } else if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        closeSearchPalette();
      }
    }

    function scrollSelectedIntoView() {
      const sel = document.querySelector('.search-palette-item.selected');
      if (sel) sel.scrollIntoView({ block: 'nearest' });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEYBOARD SHORTCUTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    document.addEventListener('keydown', (e) => {
      // Cmd+K / Ctrl+K -> search palette
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        toggleSearchPalette();
        return;
      }

      if (e.key === 'Escape') {
        // Close search palette first if open
        if (!document.getElementById('searchPalette').classList.contains('hidden')) {
          closeSearchPalette();
          return;
        }
        if (state.detailPanelSessionKey) {
          closeDetailPanel();
        } else if (state.goalPanelOpen) {
          closeGoalView();
        } else if (state.currentView === 'chat') {
          showOverview();
        } else if (state.currentView === 'goal') {
          closeGoalView();
        }
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HASH ROUTER (deep links + back/forward)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function navigateTo(path, replace) {
      var clean = String(path || '').replace(/^#\/?/, '').replace(/^\//, '');
      var url = '#/' + clean;
      if (window.location.hash === url) { handleRoute(); return; }
      if (replace) {
        history.replaceState({ path: clean }, '', url);
      } else {
        history.pushState({ path: clean }, '', url);
      }
      handleRoute();
    }

    function handleRoute() {
      var raw = (window.location.hash || '').replace('#/', '');
      var slashIdx = raw.indexOf('/');
      var route = slashIdx === -1 ? raw : raw.substring(0, slashIdx);
      var payload = slashIdx === -1 ? '' : raw.substring(slashIdx + 1);

      switch (route || 'dashboard') {
        case 'goal':
          if (payload) {
            var goalId = decodeURIComponent(payload);
            closeDetailPanel({ fromRouter: true });
            if (state.goals.length) {
              openGoal(goalId, { fromRouter: true });
            } else {
              state.pendingRouteGoalId = goalId;
            }
          } else {
            showOverview({ fromRouter: true });
          }
          break;
        case 'session':
          if (payload) {
            var sessionKey = decodeURIComponent(payload);
            closeDetailPanel({ fromRouter: true });
            if (state.sessions.find(function(s) { return s.key === sessionKey; })) {
              openSession(sessionKey, { fromRouter: true });
            } else {
              state.pendingRouteSessionKey = sessionKey;
            }
          } else {
            showOverview({ fromRouter: true });
          }
          break;
        case 'detail':
          if (payload) {
            var detailKey = decodeURIComponent(payload);
            // Ensure we're on the dashboard first
            if (state.currentView !== 'overview') {
              showOverview({ fromRouter: true });
            }
            if (state.sessions.find(function(s) { return s.key === detailKey; })) {
              openDetailPanel(detailKey, { fromRouter: true });
            } else {
              state.pendingRouteDetailKey = detailKey;
            }
          } else {
            showOverview({ fromRouter: true });
          }
          break;
        case 'dashboard':
        default:
          closeDetailPanel({ fromRouter: true });
          showOverview({ fromRouter: true });
          break;
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function init() {
      // Restore active runs from localStorage (before connecting)
      restoreActiveRuns();
      initGoalTimeFilterUI();

      connectWebSocket();

      // Hash router: back/forward navigation
      window.addEventListener('hashchange', function() { handleRoute(); });

      // Auto-refresh sessions every 30s
      setInterval(() => {
        if (state.connected) {
          refresh();
        }
      }, 30000);
    }

    init();
  </script>
  
  <!-- Media upload module -->
  <script src="/js/media-upload.js"></script>
  <!-- Voice recorder module -->
  <script src="/js/voice-recorder.js"></script>
</body>
</html>
